# Работа с файлами

## Аннотация

Данный проект позволит тебе изучить, как работать с файлами с расширениями .txt, .json и .csv.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Постановка задачи](#постановка-задачи) \
    2.2. [Работа с файлами](#работа-с-файлами) \
    2.3. [Структура папок и файлов](#структура-папок-и-файлов)
3. [Chapter III](#chapter-iii) \
    3.1. [txt-файлы](#txt-файлы) \
    3.2. [Задание 1](#задание-1) \
    3.3. [Задание 2](#задание-2) \
    3.4. [Задание 3](#задание-3)
4. [Chapter IV](#chapter-iv) \
    4.1. [json-файлы](#json-файлы) \
    4.2. [Задание 4](#задание-4) \
    4.3. [Задание 5](#задание-5) 
5. [Chapter V](#chapter-v) \
    5.1. [csv-файлы](#csv-файлы) \
    5.2. [Задание 6](#задание-6) \
    5.3. [Задание 7](#задание-7) 
6. [Chapter VI](#chapter-vi) \
    6.1. [Задание 8](#задание-8) \
    6.2. [Задание 9](#задание-9) 

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat.  Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер : 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!


### Введение

GOOOOOOOOOOOOOOOOOOD MOOOOOOOOOOOORNIIIIING VIETNAAAAAM! \
Думаешь ты про себя, однако вслух произносишь:

> Всем доброго утра!
>> **Стажер**

и проходишь к своему рабочему месту. Не успеваешь ты приземлиться на стул, как дверь в кабинет открывается, и на позитиве (как и всегда)
заходит главврач.

> GOOOOOOOOOD MOOOOOOOOOOOOOORNIIIIIING HOOOOOOOOOOSTPITAL!!!
>> **Главврач**

Мда-а, он явно не стесняется, как ты. Надо бы поучиться у него уверенности, но, возможно, и уместности тоже... \
Ты замечаешь, что следом (уже не с таким большим энтузиазмом) заходят два человека.

> Знакомься, Стажер. Эти два землекопа такие же стажеры, как и ты. Присланы к нам на ближайшие два дня для обмена IT-опытом.
> Их главврачи сказали, что они тоже шарят в компьютерах. Итак, сегодня и завтра вы будете работать в команде.
> 
> Хм-м, вас нужно как-то различать. С запоминанием имен у меня туго, поэтому вы будете: Ниф-Ниф, Наф-Наф и Нуф-Нуф, ну или: стажер №1, стажер №2 и стажер №3.
> Вот вам бейджики, чтобы я не забыл, кто есть кто, напишите на них свои новые псевдонимы.
> 
> Мой стажер будет главным поросенком, в смысле стажером №1. Не обижайтесь, ребята, ничего личного, просто я его знаю на один день дольше, чем вас.
> Ну все, развлекайтесь, в смысле работайте!
>> **Главврач**

Вы знакомитесь между собой, и ты спрашиваешь, как они оказались тут «для обмена IT-опытом».

> Перезагрузил роутер главврачу, когда у него не работал интернет...
>> **Наф-Наф (стажер №2)**

> Настроил автоответчик главврачу...
>> **Нуф-Нуф (стажер №3)**

> Принтер...
>> **Ниф-Ниф (стажер №1)**

Вы молча и с глубоким пониманием переглядывайтесь, чувствуя себя одной командой, члены которой явно совсем недавно оказались не в том месте и не в то время.

## Chapter II

### Постановка задачи

Пока вы знакомитесь, попивая чай, проходит какое-то время, и в кабинет заходит уже знакомая Ниф-Нифу (стажеру №1) Антонина Павловна (врач-терапевт).

> Всем привет! Ого, кажется, вас стало больше. Я так понимаю, что вы, ребята, по обмену? А что у вас на бейджиках написано? Ниф-Ниф, Наф-Наф, Нуф-Нуф...
> Дайте-ка догадаюсь, искромётный юмор главврача? Ну-у, это в его духе, зато профессионал и управленец он прекрасный! А чувство юмора... Ну не всем же дано хорошо петь или танцевать...
>> **Антонина Павловна (врач-терапевт)**

> ...
>> **Ниф-Ниф, Наф-Наф и Нуф-Нуф**

> А теперь к делу. Ниф-Ниф (стажер №1), я активно пользуюсь твоей программой! А это значит, что я вошла во вкус и хочу больше автоматизации!
> 
> Раз уж вас тут трое, то у меня есть для вас 3 идеи для реализации!
> 
> Первая:\
> Давно хотела вести прием электронно, а не разбирать каждый раз потом свой почерк (да, да, я сама его тоже с трудом понимаю).
> То есть хочется, чтобы все записи можно было вписывать в компьютер, и чтобы они записывались в какой-нибудь файл. 
> Плюс не хочется потом искать этот файл. Хорошо было бы просто вбить в программе нужную фамилию и дату, и вуаля — мне выводится файл с описанием прошлого приема.
> 
> Вторая:\
> Если прием будет ввестись электронно, то чтобы заменить полностью бумажную карточку, нужно создать электронную карточку пациента с его данными!
> И, естественно, мне нужно иметь возможность просматривать эту карточку. Помимо этого, хочется заводить карточку самой, если вдруг ее не оказалось в папке пациента,
> чтобы не отправлять его каждый раз за этим в нагруженную регистратуру.
> 
> Третья:\
> Возможность просмотра электронной очереди, сформированной в регистратуре. Я знаю, что сейчас она формируется только программно, но 
> я думаю, что в будущем буду иметь к ней доступ. Хочу проверять по ней, кто ко мне приходит, и отмечать это в ней.
> 
> Таким образом:
> 1. Я буду смотреть электронную очередь и проверять, тот ли пациент пришел ко мне по времени.
> 2. Могу просмотреть карточку пациента с его данными. 
> 3. Могу внести в нее изменения.
> 4. Могу посмотреть список предыдущих приемов.
> 5. Могу просматривать файлы с историей прошлых приемов, если мне понадобится.
> 6. Текущий прием буду вести в программе, которая потом все запишет в файл.
> 7. После приема отмечать в очереди, что я приняла этого пациента.
> 
> Раз уж вас трое, то давайте я разобью задачи по этим трем основным идеям, распишу их и раздам вам. Вы их втроем параллельно реализуете и дальше просто соберете все вместе.
> Договорились? Договорились.
>> **Антонина Павловна (врач-терапевт)**

Антонина Павловна выходит за дверь, и ты (Ниф-Ниф) рассказываешь своим парнокопытным товарищам про записки админа и предлагаешь изучить те записи,
которые связаны с работой с файлами.

### Работа с файлами

Вы находите папку с 4 файлами: *introduction.txt*, *txt.txt*, *csv.txt* и *json.txt*. Логично, наверное, начать с файла *introduction.txt*.

> При работе с любым файлом самое главное — два действия:
> 1. Открыть файл перед работой с ним.
> 2. Закрыть файл после работы с ним.
> 
> Если не закрыть файл, то все изменения не будут выполнены, а открытый файл будет занимать память компьютера.
> Есть два метода работы с этими действиями. Первый метод — ручной.
> 
> Ты вручную открываешь файл с помощью метода `open` и записываешь это в переменную:
> 
> `file = open('folder/text.txt', 'r', encoding='utf-8')`
> 
> Первый аргумент `'folder/text.txt'` — это путь к файлу, который нужно открыть. Путь может быть относительным (относительно текущей рабочей папки) и абсолютным, то есть начинаться с корневой папки в системе.
> Когда будешь делать задания, у тебя могут возникать ошибки, которые говорят, что файла по такому пути нет, особенно если путь указан относительным.
> Не забудь при запуске в настройках указать рабочей папку с проектом, как на примере ниже.
> 
> ![Рабочая директория 1](misc/images/working_directory_1.png) ![Рабочая директория 2](misc/images/working_directory_2.png)
> 
> Второй аргумент `'r'` — это режим открытия файла, данный режим открывает файл на чтение. Есть режимы на запись, дозапись и т. д.
> Их ты можешь легко загуглить.
> 
> Третий аргумент `encoding='utf-8'` — это кодировка. Что это такое, можешь прочитать в интернете, самый распространенный — это **utf-8**.
> Если при чтении или записи вместо нормальных символов ты видишь крокозябры или какие-то непонятные сочетания символов и цифр, то это проблема с кодировкой.
> 
> После чтения с аргументом `file` ты уже начинаешь осуществлять операции. Когда все операции завершены, надо закрыть файл с помощью метода **close**:
> 
> `file.close()`
> 
> А теперь поговорим о втором методе — работа с контекстным менеджером `with`. Если файл был открыт через блок `with`, то
> он автоматически будет закрыт, когда код внутри `with` будет выполнен.
> 
> ```python
> with open('folder/text.txt', 'r', encoding='utf-8') as file:
>   something_code...
> ```
> 
> Советую сразу приучаться работать с файлами через блок `with`. На самом деле, `with` работает не только с файлами,
> но это уже сложные и продвинутые темы.
> 
> Подводя итог, можно сказать, что любая работа с файлами содержит часть с открытием и закрытием файла.
> В случае файлов с форматом *.txt* больше ничего не требуется. Для других форматов, например, *.csv* или *.json*, есть соответствующие библиотеки.

### Структура папок и файлов

Когда вы уже заканчиваете чтение, в комнату входит Антонина Павловна и отдает вам копну листов.

> Я накидала здесь вам задания, разделив их на три блока. Если хотите, то можете, собственно, взять по одному блоку на каждого, 
> а потом уже все объедините в одно. Успехов вам.
>> **Антонина Павловна (врач-терапевт)**

Вы смотрите в записи и понимаете, что все 3 блока тематически разбиты на работу с 3 разными форматами файлов: *.txt*, *.csv* и *.json*.
Также в самом начале записей есть подчеркнутый пункт с пометкой **«ДЛЯ ВСЕХ»**.

> Я подумала, что данные о пациентах будут храниться в единой папке. Я сделала вам пример такой папки и залила его в GitLab (да, я и такое умею!).
> Папка называется *patients/* и находится в *materials/*.
> 
> Внутри лежат папки, имена которых соответствуют ФИО пациентов. Заметьте,
> что все они выглядят единым образом — *Фамилия_Имя_Отчество* на английском языке. 
> 
> Внутри каждой из папок лежит файл *card.json*. Данный формат для хранения карточек пациентов подсказал мне главврач. 
> И откуда он только это знает?
> 
> Помимо файла *card.json*, в папках пациентов присутствует папка *visits*, в которой находятся текстовые файлы. Каждый из файлов содержит записи с одного приема.
> Название файла всегда выглядит как дата в формате *год-месяц-день* (*2024-03-10.txt*).
> 
> Помимо папки *materials/patients*, внутри папки *materials* лежит файл *schedule.csv*, в котором записана электронная очередь в специальном формате *.csv*.
> Я слышала, данный формат может открываться с помощью Экселя и других подобных программ. Поэтому будем использовать его.
> Я накидала пример, чтобы вы могли написать свои программы.
> 
> Также передаю слова нашего главврача: «Перед тем как работать с этими папками и файлами, **СКОПИРУЙТЕ** их в свою папку *src/*.
> А в программах указывайте пути к папкам и файлам, которые лежат в *src/*. Все пути должны быть относительными (относительно вашей рабочей папки, то есть папки с репозиторием)».

Вы договаривайтесь между собой, Наф-Наф (стажер №2) и Нуф-Нуф (стажер №3) копируют на флешки подсказки админа, и вы расходитесь по отдельным компьютерам.

## Chapter III

### txt-файлы

Один из стажеров взял блок с текстовыми файлами. Перед выполнением задания этот стажер открывает нужный файл от админа и видит:

> Файлы с расширением *.txt* — это обыкновенные текстовые файлы, которые обычно открываются с помощью какого-нибудь блокнота.
> Простой как три копейки, данный формат используется просто для каких-то текстовых записей, часто неформатированных.
> 
> С точки зрения кода, данный формат не требует использования каких-то внешних библиотек. Есть много полезных методов для работы 
> с текстовыми файлами, записанными в переменную: `read(), readline(), write()` и многие другие. Одни читают весь файл, другие читают построчно, и 
> их можно прогонять в цикле, другие считывают строки и записывают их отдельно в элементы списка. Перед работой с ними постарайся найти нужный тебе
> в данный момент времени.

### Задание 1

Отлично, можно приступить к заданиям. Стажер обращается к записям Антонины Павловны.

> В первом задании я хочу, чтобы ты научился читать текстовые файлы. А именно я хочу вводить фамилию, имя и отчество пациента,
> дату старого приема, за который я хочу почитать записи, и вывести содержимое на экран. Если же файла нет, хочу, чтобы меня об этом уведомляли.
> При этом ФИО пусть будет невосприимчиво к регистру, т. е. я могу ввести: Ivanov Ivan Ivanovich, ivanov ivan ivanovich, Ivanov ivan Ivanovich и т. д.
> И кстати, если я неправильно введу ФИО, то пусть программа также уведомляет об отсутствии такого пациента!

Перед выполнением заданий необходимо скопировать папку *materials/patients* и файл *materials/schedule.csv* в папку *src/*.

**ВСЕ ПУТИ В ТАСКАХ НУЖНО УКАЗЫВАТЬ К ПАПКАМ И ФАЙЛАМ В ПАПКЕ *src/*!!!**

Получается, что первый стажер (кто же это будет? Ниф-Ниф, Наф-Наф или Нуф-Нуф?) должен реализовать следующий функционал:
1. Врач вводит в клавиатуры:
   - фамилию, имя и отчество — `Ivanov Ivan Ivanovich`;
   - дату интересующего приема — `2024-09-03` (если пациент существует).
2. При вводе с клавиатуры врач должен видеть следующие надписи в разных инпутах (порядок инпутов обязателен):
   - `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): `;
   - `Enter the date of the appointment you want to watch: ` (если пациент существует).
3. Текст, который видит врач при вводе, должен быть выведен на экран только с помощью `input`, а не через `print`!
4. Врач может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
5. После ввода ФИО необходимо СРАЗУ проверить, существует ли папка с таким пациентом. Если НЕТ, то нужно выводить фразу: `There is no such patient!` и **завершить программу**.
6. С помощью введенных данных нужно сформировать путь до нужного файла и прочитать содержимое.
7. Содержимое файла вывести на экран.
8. Если файл не был найден, то выводить на экран фразу: `There was no such appointment with the doctor!`.

Нужно подумать, как проверить наличие папки с пациентом. Кажется, другой стажер что-то говорил тебе про модуль *os*, надо будет покопать в том направлении.

P.S. Надо не забыть, что для подстановки каких-то частей пути в полный путь до файла или папки отлично подойдут **f-строки**.

### Задание 2

> После этого я хочу, чтобы ты реализовал следующее: после ввода мной ФИО (регистронезависимость оставляем) пусть мне показывается список предыдущих приемов.
> Если же приемов не было, то пусть пишет, что это первый прием, и программа прекращает работу. Если же приемы есть, то дальше
> пусть делает то же самое, что и в 1 задании.

Получается, что:
1. Врач вводит в клавиатуры:
   - фамилию, имя и отчество — `Ivanov Ivan Ivanovich`;
   - дату интересующего приема — `2024-09-03` (если пациент существует).
2. При вводе с клавиатуры врач должен видеть следующие надписи в разных инпутах (порядок инпутов обязателен):
   - `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): `;
   - `Enter the date of the appointment you want to watch: ` (если пациент существует и это его не первый прием).
3. Врач может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Текст, который видит врач при вводе, должен быть выведен на экран только с помощью `input`, а не через `print`!
5. После ввода ФИО необходимо СРАЗУ проверить, существует ли папка с таким пациентом. Если НЕТ, то нужно выводить фразу: `There is no such patient!` и **завершить программу**.
6. После ввода ФИО (например, `Ivanov Ivan Ivanovich`) необходимо выводить на экран:
   
   **ЕСЛИ** папка *visits* существует, то: 
   - ```
     Previous doctor appointments:
     2024-09-03
     2024-09-06
     2024-09-10

   **ИНАЧЕ** (если папки *visits* не существует):
   - `This is the first appointment with the doctor!` и **после этого вывода программа завершает работу**.
7. Если программа не завершила работу (предыдущие приемы существуют), то запросить ввод даты интересующего приема, а после повторить пункты 6-8 из **Задания №1**.

А как же посмотреть, сколько и какие файлы в папке *visits*? Надо попробовать поискать в том же модуле *os*.

### Задание 3

> Последним в этом блоке я хочу реализацию ввода записей текущего приема. Воспринимай это задание, не как продолжение предыдущего, а как отдельное. 
> Пусть я также буду вводить ФИО пациента (регистронезависимость оставляем),
> после этого пусть я смогу вводить любые записи, и при вводе двух пустых строк записи бы фиксировались в файле.
> При этом один Enter пусть работает как обычный перенос строки, два Enter подряд — это два переноса, то есть добавление пустой строки.
> Три Enter — это уже две пустые строки, а значит, конец ввода записей.
> И сделай, пожалуйста, такой же формат файла, как и в других приемах.

Что ж, выходит:
1. Врач вводит с клавиатуры:
    - фамилию, имя и отчество — `Ivanov Ivan Ivanovich`;
    - любые записи, которые он хочет сохранить в файл.
2. При вводе с клавиатуры врач должен видеть следующие надписи в разных инпутах (порядок инпутов обязателен):
   - `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): `;
   - `Enter records for the current appointment (to finish press Enter twice): ` (при этом надпись должна выводиться перед многострочным вводом один раз с помощью **print**).
3. Врач может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Текст, который видит врач при вводе ФИО, должен быть выведен на экран только с помощью `input`, а не через `print`!
5. После ввода ФИО необходимо СРАЗУ проверить, существует ли папка с таким пациентом. Если НЕТ, то нужно выводить фразу: `There is no such patient!` и **завершить программу**.
6. Врач должен осуществлять многострочный ввод с возможностью переноса строки и пропуска одной строки.
При этом, если он пропустил 2 строку, то ввод должен прекращаться. Пример (слева проставлена нумерация строк, она не вводится и нужна, чтобы отследить пустые строки) окна вывода в PyCharm:
```
1 Enter records for the current appointment (to finish press Enter twice):
2 Bla-bla-bla
3 
4 Tum-tum-tum
5 
6 Pum-pum-pum
7
8
9
10 Process finished with exit code 0 (это конец программы)
```
7. Все записи должны быть записаны в файл.
8. Файл должен называться, как текущая дата. Допустим, сегодня — 2024-09-01. Тогда записи записываются в файл *visits/2024-09-01.txt*.
9. Текущую дату необходимо определять в момент выполнения программы, а не фиксировать в коде.
10. Внутри записанного файла после последней строки с символами должна быть одна пустая строка (**не больше!**). Можно посмотреть примеры файлов со всеми остальными приемами.
Пример содержимого сформированного файла (слева проставлена нумерация строк, она нужна, чтобы отследить пустые строки):
```
1 Bla-bla-bla
2 
3 Tum-tum-tum
4 
5 Pum-pum-pum
6
```

Кажется, что в записях админа ты видел, как определить текущую дату на момент выполнения программы. Вроде бы модуль *datetime* должен тебе помочь, если тебе не изменяет память.

## Chapter IV

### json-файлы

Кто-то другой взял блок с json-файлами. Перед выполнением задания этот стажер открывает нужный файл от админа и видит:

> Файлы с расширением *.json* — это специальный формат файлов, который изначально пришел с другого языка программирования,
> а именно с JavaScript. Json-файлы — это структурированные файлы, и самое приятное, что в Python есть тип данных, который
> очень похож на формат json-файлов — словари. Json-файлы устроены почти так же, как и словари (хотя, возможно, это словари устроены почти так же, как json). Тоже ключи, тоже значения.
> Отличие в том, какие типы данных могут быть записаны в *.json* в качестве ключей и значений.
> 
> С точки зрения кода, данный формат уже требует библиотеки для комфортной работы с файлами. Библиотека так и называется — `json`.
> Принцип работы с *.json* файлами следующий: ты открываешь файл как обычно с помощью `with` и записываешь его в какую-нибудь переменную **file** (см. общие принципы работы с файлами), 
> а дальше внутри блока `with` с помощью библиотеки вызываешь методы, которые отвечают за чтение и запись файла. 
> 
> Обязательно разберись, в какой питоновский формат будет прочитан *.json* файл с помощью библиотеки `json`. И из какого формата удобнее всего записывать данные в *.json*-файл.

### Задание 4

> В этом блоке я хочу, чтобы ты поработал с карточками пациентов. Повторюсь, что они лежат в папках пациентов, файл — *card.json*.
> В первом задании блока я хочу, чтобы при указании фамилии, имени и отчества пациента мне выводилась его карточка. 
> При этом ФИО пусть будет невосприимчиво к регистру, т. е. я могу ввести — Ivanov Ivan Ivanovich, ivanov ivan ivanovich, Ivanov ivan Ivanovich и т. д.
> Как и в заданиях из первого блока, предусмотри, что если я неправильно введу ФИО, то пусть программа уведомляет меня об отсутствии такого пациента!
> Также нужно проверять, есть ли карточка в папке, и если ее нет, то предупреждать об этом.

Итого:
1. Врач вводит в клавиатуры:
   - фамилию, имя и отчество — `Ivanov Ivan Ivanovich`.
2. При вводе с клавиатуры врач должен видеть следующую надпись: `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): ` (с помощью `input`, а не через `print`).
3. Врач может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. После ввода ФИО необходимо СРАЗУ проверить, существует ли папка с таким пациентом. Если НЕТ, то нужно выводить фразу: `There is no such patient!` и **завершить программу**.
5. Если папка существует, то необходимо выводить на экран содержимое файла *card.json*, который лежит в папке этого пациента.
6. Если файла *card.json* не существует, то необходимо вывести на экран фразу: `There is no patient card!` и **завершить программу**.
7. Вывод существующей карточки на экран должен быть таким же, как данные, записанные в файле. При этом отступы от начала строк до ключей должны составлять 4 пробела. Пример вывода в терминале:
```
{
    "Surname": "Ivanov",
    "Name": "Ivan",
    "Patronymic": "Ivanovich",
    "Date of birth": "1994-11-23",
    "Sex": "M"
}
```
### Задание 5

> После того как научился читать карточки пациентов, давай сделаем возможность мне создавать карточку для тех пациентов, у которых ее нет.
> То есть нужно проверять, есть ли карточка в папке, и если ее нет, то предупреждать об этом и давать возможность по порядку ввести все поля в карточке.
> После этого было бы неплохо ее также вывести на экран. При вводе данных для карточки — фамилии, имени, отчества и пола — нужно также обрабатывать любой регистр.
> При этом в файл данные должны записываться в тех регистрах, в каких они записаны в других карточках.

Получается, что:
1. Врач вводит в клавиатуры:
   - фамилию, имя и отчество — `Ivanov Ivan Ivanovich`;\
    Если такой пациент есть, но его карточка отсутствует:
   - фамилию (surname) — `Ivanov`;
   - имя (name) — `Ivan`;
   - отчество (patronymic) — `Ivanovich`;
   - дата рождения (date of birth) — `1993-03-20`;
   - пол (sex) — `M` (обратите внимание, что это **английская буква** от слова Man).
2. При вводе с клавиатуры врач должен видеть следующие надписи в разных инпутах (порядок инпутов обязателен):
   - `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): `;\
   Если такой пациент есть, но его карточка отсутствует:
   - `Enter the surname of patient: `;
   - `Enter the name of patient: `;
   - `Enter the patronymic of patient: `;
   - `Enter the date of birth of patient (1994-01-10): `;
   - `Enter the sex of patient (M or W): `.
3. Врач может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. После ввода ФИО необходимо СРАЗУ проверить, существует ли папка с таким пациентом. Если НЕТ, то нужно выводить фразу: `There is no such patient!` и **завершить программу**.
5. Если папка существует, то необходимо выводить на экран содержимое файла *card.json*, который лежит в папке этого пациента. При этом выводить на экран карточку нужно ровно в том же виде, как она записана в файле.
6. Если файла *card.json* не существует, то необходимо вывести на экран фразу: `There is no patient card!`.
7. После вывода этой фразы нужно сразу дать пользователю ввести нужные данные для карточки (см. пункт 1 и 2).
8. Введенные для карточки данные надо преобразовать в тот регистр, который принят для этих данных во всех карточках (см. карточки других пациентов).
9. Сформированную карточку необходимо записать в файл *card.json* в папку пациента в том формате, что и карточки других пациентов.
10. После этого необходимо вывести на экран сформированную карточку, как в пункте 5.

## Chapter V

### csv-файлы

Последнему стажеру достался блок с csv-файлами. Не изменяя команде, он тоже изначально лезет в записи админа:

> Файлы с расширением *.csv* — это текстовые файлы, предназначенные для записи табличных данных. С csv-файлами умеют работать как Excel, так и другие подобные программы.
> Это очень популярный формат файлов. Каждая строка в файле — это строка таблицы. Первая строка — это обычно строка с заголовками колонок.
> Колонки между собой разделяются с помощью **разделителей** (прости за тавтологию). По умолчанию используется запятая. Однако в качестве разделителя 
> можно использовать и другие символы, главное, чтобы они не встречались внутри значений в полях таблицы.
> То есть если в качестве разделителя выбрана запятая, но одна из колонок содержит текст с запятыми внутри него, то чтение такого файла сто процентов будет неверным.
> В данном случае лучше использовать другой разделитель, например, `|`.
> 
> С точки зрения кода, данный формат (как и json) требует библиотеки для комфортной работы с файлами. Библиотека так и называется — **сsv**.
> Принцип работы с *.csv* файлами следующий: ты открываешь файл как обычно с помощью `with` и записываешь его в какую-нибудь переменную **file** (см. общие принципы работы с файлами), 
> а дальше внутри блока `with` с помощью библиотеки вызываешь методы, которые отвечают за чтение и запись файла.
> 
> Важное отличие при работе с csv-файлами заключается в том, что внутри функции `open` нужно еще использовать аргумент **newline**.
> Не забудь про него, когда будешь обрабатывать такие файлы!

### Задание 6

> В данном блоке мне бы хотелось работать с электронной очередью, которая записана в файле *schedule.csv* (который ты, надеюсь, скопировал в папку *src/* из папки *materials/*).
> Для начала нужно просто выводить эту электронную очередь на экран в красивом виде. Как это сделать, спроси у нашего стажера (если ты, конечно, не он) — 
> он знает.

План выполнения задания:
1. Прочитать файл *schedule.csv*.
2. Вывести на экран содержимое файла с помощью библиотеки `tabulate`, используя формат ***github***.
3. Пример вывода:
```
| Time   | Patient                     | The patient visited the doctor   |
|--------|-----------------------------|----------------------------------|
| 08:00  | Ivanov Ivan Ivanovich       | No                               |
| 08:30  | Petrov Petr Petrovich       | No                               |
| 09:00  | Sidorova Svetlana Sergeevna | No                               |
| 09:30  | Maximova Elena Petrovna     | No                               |
```

### Задание 7

> Для второго задания этого блока у меня есть следующая задумка. В электронной очереди есть колонка `The patient visited the doctor`.
> По умолчанию у всех пациентов стоит значение `No`. Хотелось бы, чтобы после приема в электронной очереди это значение
> менялось на `Yes`. Давай начнем с того, чтобы я вводила ФИО пациента (регистронезависимое, само собой), после этого в электронной
> очереди должно меняться значение у этого пациента с `No` на `Yes`, то есть файл *schedule.csv* должен быть обновлен.
> 
> Если же пациента нет в очереди, то пусть программа предупреждает об этом и завершается.

Для реализации этого задания нужно учесть следующие пункты:
1. Врач вводит в клавиатуры:
   - фамилию, имя и отчество — `Ivanov Ivan Ivanovich`.
2. При вводе с клавиатуры врач должен видеть следующую надпись: `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): ` (с помощью `input`, а не через `print`).
3. Врач может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым записываются ФИО в очереди.
4. Необходимо прочитать файл *schedule.csv*.
5. После необходимо проверить, есть ли данный пациент в очереди. Если НЕТ, то нужно выводить фразу: `There is no such patient!` и **завершить программу**.
6. Если пациент есть, то нужно в его строке очереди в колонке `The patient visited the doctor` заменить значение `No` на `Yes`.
7. Далее очередь должна записаться в тот же файл *schedule.csv* в том же виде, как и до этого, просто с одним измененным значением.
8. В конце очередь с измененным значением должна выводиться на экран в том же виде, что и в **Задании №6** (см. пункты 2-3).

## Chapter VI

### Задание 8

После выполнения трех блоков Ниф-Ниф, Наф-Наф и Нуф-Нуф собираются вместе. Немного уставшими руками они открывают последнюю по нумерации
записку, в которой сказано, как собрать все три блока вместе. Из этой записки видно, что просмотр электронной очереди врач хочет просматривать отдельно, а вот все остальные наработки в том или ином виде входят в итоговую программу.

По истечении некоторого времени совместного мозгового штурма вам удается накидать план итоговой программы:
1. При запуске программы запрашивать ФИО: `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): `.
2. Выполнить пункты 3-10 из **Задания №5**. Для ввода карточки использовать информацию из пункта 1-2 **Задания №5**.
При этом необходимо не забыть, что согласно пункту 4 из **Задания №5**, программа **может завершиться**! 
3. После вывода на экран карточки пациента (существующей или же только введенной) врач должен видеть в терминале следующую информацию и приглашение к вводу (количество черточек должно равняться **50**,
при этом текст, который видит врач при вводе ФИО, должен быть выведен на экран только с помощью `input`, а не через `print`):
```
--------------------------------------------------
Enter:
 - 1, if you want to see a list of dates of previous visits;
 - 2, if you want to see the recording of the previous visit;
 - 3, if you want to start recording in the current visit;
 - 4, if you want to finish the appointment and complete the program.
--------------------------------------------------
```
4. Врач может выбирать любые опции до бесконечности, пока не будет выбрана опция 4!
5. При вводе опции 1 необходимо:
   
   **ЕСЛИ** папка *visits* существует, то: 
   - ```
     Previous doctor appointments:
     2024-09-03
     2024-09-06
     2024-09-10

   **ИНАЧЕ** (если папки *visits* не существует):
   - `This is the first appointment with the doctor!`.
6. При вводе опции 2 необходимо:

    **ЕСЛИ** папка *visits* существует, то: 
   - `Enter the date of the appointment you want to watch: `
   
        **ЕСЛИ** такой прием есть, то вывести содержимое на экран без обработки,
     
        **ИНАЧЕ** выводить фразу: `There was no such appointment with the doctor!`.

   **ИНАЧЕ** (если папки *visits* не существует):
   - `This is the first appointment with the doctor!`.
7. При вводе опции 3 необходимо выполнить пункты 6-10 из **Задания 3**.
8. При вводе опции 4 необходимо:
   - прочитать файл *schedule.csv*;
   - в строке c ФИО принимаемого пациента в колонке `The patient visited the doctor` заменить значение `No` на `Yes`.
   - записать обновленную очередь в тот же файл *schedule.csv* в том же виде, как и до этого, просто с одним измененным значением.
   - **завершить программу**!!!

> Пример работы программы можно посмотреть в *materials/example_of_work.txt*.
>> **Голос свыше**

### Задание 9

Под конец рабочего дня, когда вы дописываете последние строчки кода, в кабинет входит Антонина Павловна.

> Как успехи, пятачки?! У-у-у, видок у вас, как будто волк в лице IT сдул у всех вас крыши...
> 
> Давайте показывайте, что у вас получилось. Так, угу, а если нажать это, правильно, а если сюда.
> 
> Выглядит все отлично! Вы великолепно потрудились! Всем большое спасибо, бегите отдыхать.
> Только, Ниф-Ниф, не забудь, пожалуйста, залить все на GitLab в ветку `develop`. 
> 
> Только есть **один важный нюанс** (!!!). Чтобы мы могли быстро все проверить, удали, пожалуйста, папку *src/patients/* и файл *src/schedule.csv*, в которые ты уже мог внести изменения.
> А потом заново скопируй *materials/patients/* и файл *materials/schedule.csv* в папку *src/*. Это нужно, чтобы проверить работу твоего кода на исходных файлах.
> 
> Все, хорошего вечера, увидимся!
>> **Антонина Павловна (врач-терапевт)**

Получается, что необходимо:
1. Удалить папку *src/patients/* и файл *src/schedule.csv*.
2. Заново скопировать *materials/patients/* и файл *materials/schedule.csv* в папку *src/*.
3. **Запушить** все файлы с кодом + папку *src/patients/* и файл *src/schedule.csv* на **GitLab** в ветку `develop`.

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.

