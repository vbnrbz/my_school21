# ООП (продолжение)

## Аннотация

Данный проект позволит тебе изучить 3 принципа ООП: инкапсуляцию, наследование и полиморфизм.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Инкапсуляция](#инкапсуляция) \
    2.2. [Задание 1](#задание-1)
3. [Chapter III](#chapter-iii) \
    3.1. [Наследование](#наследование) \
    3.2. [Задание 2](#задание-2) \
    3.3. [Задание 3](#задание-3)
4. [Chapter IV](#chapter-iv) \
    4.1. [Полиморфизм](#полиморфизм) \
    4.2. [Задание 4](#задание-4) 
5. [Chapter V](#chapter-v) \
    5.1. [Абстрактные классы](#абстрактные-классы) \
    5.2. [Задание 5](#задание-5) 
6. [Chapter VI](#chapter-vi) \
    6.1. [Методы класса](#методы-класса) \
    6.2. [Задание 6](#задание-6) 
7. [Chapter VII](#chapter-vii) \
    7.1. [Задание 7](#задание-7)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер: 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

Новый день — новые вызовы! Ты сидишь в своем кабинете, когда дверь открывается, и в кабинет входит главврач.

> Доброе утро! Ну что, ты уже постиг ООП, как я тебе и советовал?
>> **Главврач**

> Здравствуйте! Кажется, концепцию я понял, но нужно больше практики.
>> **Стажер**

> Золотые слова! Так чего откладывать в долгий ящик. Я сегодня поговорил с коллективом, ближайшие два дня у всех есть свои дела, и твоя
> помощь вроде как пока никому не требуется. Ни программы, ни принтер перезапустить.
>> **Главврач**

> ...
>> **Стажер**

> Да шучу я! Все такие серьезные пошли в наше время, что забывают про мать нашу иронию и ее странную сестру метаиронию.
> 
> А теперь давай к делу. Я тут глянул твой код в GitLab. И вот опять тот же удивленный взгляд, как будто один ты умеешь в GitLab заходить
> и простой код читать. Так вот, как насчет того, чтобы немного расширить свои знания по ООП?
>> **Главврач**

> Я не против, но, кажется, записи от админа по ООП закончились, я все просмотрел.
>> **Стажер**

> Ты в этом уверен? Я бы на твоем месте еще раз бы глянул, а то, может, не заметил вчера что-то.
> А у меня как раз есть задача под новые знания. Ты же недавно с другими стажерами писал код для работы с файлами, не так ли?
> Как насчет того, чтобы перенести всю эту логику в старый добрый ООП?
> 
> В общем, посмотри еще раз свои файлы, начни изучать, я вернусь чуть попозже и начну ставить тебе задачу. Договорились?
>> **Главврач**

> Да, хорошо, как скажете.
>> **Стажер**

## Chapter II

### Инкапсуляция

Ты на 100% уверен, что никаких больше записей по ООП не было на момент вчерашнего изучения. Но обещание есть обещание, надо глянуть еще разок.
Ты просматриваешь список файлов и замечаешь файл *oop_continue.txt*. Что?! Ты готов поклясться, что его здесь не было...
Какая-то магия вне Хогвартса... Ладно, если есть время задуматься о происхождении файла, то есть время и прочитать его.
Ты открываешь файл.

> В прошлом файле по ООП я хоть и пытался рассказать про принципы ООП, но забыл упомянуть 3 основных (или базовых) принципа данного
> подхода к программированию, а именно:
> 1. **Инкапсуляция**;
> 2. **Наследование**;
> 3. **Полиморфизм**.
>
> Звучит страшно, но пугаться не стоит. Разберем их по порядку.
> 
> **Инкапсуляция** — это ограничение доступа к некоторым компонентам (атрибутам и методам) объекта. То есть методы и атрибуты объекта
> имеют разные уровни доступа. Стандартные методы и атрибуты объектов имеют публичный доступ и доступны к вызову из других частей кода.
> Но помимо публичного доступа, для атрибутов и методов можно закрыть доступ извне, то есть сделать его приватным.
> 
> Ты уже должен быть знаком с приватными методами. Они начинаются с двух нижних подчеркиваний. То же самое и с приватными атрибутами:
> если перед атрибутом объекта поставить два нижних подчеркивания, то он не будет доступен напрямую из кода вне описания класса 
> (на самом деле, Python — тот еще язык, он позволяет хитрым способом обращаться даже к приватным компонентам, но с чуть большим геморроем, 
> что все-таки позволяет прикрыть простой доступ).
> 
> Зачем это нужно? Не забывай, что разработчики часто пишут свой код скопом или же подхватывая друг у друга.
> И самый первый разработчик, который описывает класс, может захотеть оставить для других простой доступ только к определенным
> методам, чтобы, как говорится, не лезли куда не надо. Меньше лезут — меньше вероятность, что что-то сломают.
> 
> Подводя итог, ООП позволяет присваивать разный уровень доступа компонентам класса (атрибутам и методам).

### Задание 1

Голос из-за спины

> Прочитал про инкапсуляцию? На самом деле, ты уже узнал про нее еще вчера, просто сейчас узнал, как это называется.
>> **Главврач**

Ты подскакиваешь на стуле, почти полностью завершив мгновенное перемещение души из своего логова в пятки.

> Чего ты такой шуганный? Я, конечно, не Ален Делон, но и не настолько страшный, чтобы Богу душу отдавать.
> 
> Ладно, хиханьки в сторону. Давай освежим знания инкапсуляции и базового ООП на практике. Как я уже говорил, хочется написать
> такой код через ООП, который мог бы в итоге помочь при работе с разными видами файлов, а может, и папок. 
> Это очень частый тип подзадач, так давай организуем его во что-то вразумительное.
> 
> Начнем с немного отдаленного. Реализуй класс, который будет верхнеуровнево работать с элементами файловой системы — с файлами и папками.
> Пусть объект этого класса при инициализации принимает путь до файла или папки и сразу проверяет, существует ли по данному пути что-то.
> И если существует, то что это — файл или папка? Запиши все это в атрибуты объекта при его инициализации, включая путь до элемента файловой системы. А методы для определения 
> значения этих атрибутов сделай, как завещала нам инкапсуляция, приватными.
> 
> Кстати, можешь попробовать новую для себя библиотеку — `pathlib`. Я видел, что ты раньше работал через `os`
> при работе с файлами. Я тебе не запрещаю, можешь продолжить работать с ней, но `pathlib` мне кажется гораздо легче и удобнее.
> 
> И да, я там в гитлабе подготовил тебе шаблон проекта и папку с шаблонами разных файлов. Пригодится для заданий и 
> проверки себя — папка *materials/files_for_tests*.
>> **Главврач**

Итак, покумекав и набросав план работ, у тебя получается:
1. В файле *src/handler_1_element.py* создать класс `FileSystemElementHandler`. В этом классе создать:
    - метод `__init__`, который принимает один аргумент — путь к файлу/папке. Внутри определить три атрибута объектов: 
`file_path`, `is_file_exists` и `type`. В первый надо записать путь, который передается, во второй — булевый флаг, существует ли элемент (`True` или `False`), 
в третий — тип элемента (`'file'` или `'directory'`) в случае существования элемента и `None`, если элемент не существует. 
При этом `is_file_exists` и `type` нужно определять с помощью внутренних приватных методов;
    - приватный метод `__element_exists`, который должен проверять существование элемента и возвращать `True` или `False`. 
Вызов нужно осуществлять в `__init__`, а результат присваивать в атрибут `is_file_exists`. Метод не должен принимать на вход какие-либо аргументы (кроме self);
    - приватный метод `__get_element_type`, который должен проверять, является ли элемент файлом или папкой. 
Должен возвращать одно из двух значений: `'file'` или `'directory'`. Вызов нужно осуществлять в `__init__`, а результат присваивать в атрибут `type`. 
Метод не должен принимать на вход какие-либо аргументы (кроме self).
2. В файле *src/task_1.py* необходимо реализовать функцию `main`, в которой прописать всю основную логику. То есть все пункты, в которых явно 
не указано, где их нужно реализовывать, реализовывать в функции `main`.
3. Вызов функции `main` осуществить в блоке `if __name__ == "__main__":` (**далее во всех заданиях пункт 2 и 3 ОБЯЗАТЕЛЬНЫ!**).
4. Пользователь вводит с клавиатуры путь к элементу: `Enter the path to the file or folder: ` (текст, сопровождающий ввод, выводится через инпут, а не принт,
**во всех остальных заданиях — аналогично!**).
5. Необходимо создать объект класса `FileSystemElementHandler`.
6. С помощью атрибутов этого объекта необходимо выводить на экран следующую строку: 
`<путь> - <флаг существования файла> (<тип элемента>)`. Примеры выводов на экран:
   - `materials - True (directory)` — для папки;
   - `materials/files_for_tests/card.json - True (file)` — для файла;
   - `asd - False (None)` — если элемент не существует.

P.S. Надо не забыть выставить в качестве рабочей папки папку с проектом. Иначе пути будут считываться неправильно.
P.P.S. После того как будет назначена рабочая папка, все пути надо писать относительно нее с помощью обычной строки (не через `pathlib`).

## Chapter III

### Наследование

Пора двигаться дальше, и ты снова погружаешься в изучение ООП.

> Второй (и уже новый для тебя) принцип ООП — это **наследование**. Наследование позволяет наследовать один класс от другого.
> Их можно условно назвать **родительский** класс и **дочерний** класс (тот, что наследуется от родительского). 
> Дочерние классы наследуют все атрибуты и методы родительского класса. Давай вернемся к кошкам. Представь, что существует родительский класс «Животное»,
> у которого есть метод «кушать» (ведь все животные едят).
> ```python
> class Animal:
>   def eat(self, meal):
>       print(f'Мммм, какая вкусная еда — {meal}')
> ```
> При этом есть определенный вид животных Кошки, которые имеют все общие признаки животного (в нашем случае — тоже едят),
> но у них добавляется особенность — смотреть на человека с презрением! Признай, не все животные так делают... Сложно представить
> оленя или медведя, которые смотрят на тебя осуждающе, но вот кошку — легко! Наследование класса осуществляется следующим образом:
> ```python
> class Cat(Animal):
>   def look_with_contempt(self):
>       print(f'Жалкий человечишка, тебе повезло, что у меня нет противопоставленного большого пальца, чтобы открывать себе консервы!')
> ```
> После наследования объекты данного класса могут вызывать атрибуты и методы класса родителя. Например:
> ```python
> murzik = Cat()
> murzik.eat('молочко')
> ```
> Для чего это нужно? Как видно из примера с кошечками, какие-то атрибуты и методы могут быть характерны для одних сущностей, но не характерны для других.
> При этом они могут иметь между собой и много общего. Вот чтобы это общее не копировать в каждый из классов, и существует наследование.
> 
> Говоря про наследование, стоит упомянуть метод `__init__`. Он вызывается при инициализации объекта класса. Но что делать, если
> у родителя и у дочернего класса два разных метода `__init__`? При этом создании объекта дочернего класса хочется вызывать оба метода — 
> и у родителя, и у дочернего. Допустим:
> ```python
> class Animal:
>   def __init__(self, kind):
>       self.kind = kind
> 
>   def eat(self, meal):
>       print(f'Мммм, какая вкусная еда - {meal}')
> 
> class Cat(Animal):
>   def __init__(self, name):
>       self.name = name
> 
>   def look_with_contempt(self):
>       print(f'Жалкий человечишка, тебе повезло, что у меня нет противопоставленного большого пальца, чтобы открывать себе консервы!')
> 
> cat = Cat('Мурзик')
> print(cat.kind)
> ```
> Данный код выдаст ошибку, скопируй его и запусти — проверь сам. Почему? Потому что атрибут `kind` определяется в `Animal`,
> в методе `__init__`, который вызывается при инициализации объекта класса `Animal`, этой инициализации не было. Как же быть в таком случае?
> 
> Для таких случаев есть метод `super()`, который позволяет обращаться к родительским классам изнутри дочерних. Я приведу один пример
> его использования, а как он работает глубже, разберись сам:
> ```python
> class Animal:
>   def __init__(self, kind):
>       self.kind = kind
> 
>   def eat(self, meal):
>       print(f'Мммм, какая вкусная еда - {meal}')
> 
> class Cat(Animal):
>   def __init__(self, kind, name):
>       super().__init__(kind)
>       self.name = name
> 
>   def look_with_contempt(self):
>       print(f'Жалкий человечишка, тебе повезло, что у меня нет противопоставленного большого пальца, чтобы открывать себе консервы!')
> 
> cat = Cat('Дворовый', 'Мурзик')
> print(cat.kind)
> ```
> Вот этот код уже не выдаст ошибку, потому в методе `__init__` класса `Cat` был явно вызван метод `__init__` родительского класса.
> 
> Последняя ремарка — наследование может быть множественным. То есть один класс может наследовать сразу от двух классов.
> Однако тут может начинаться путаница. Особенно если у классов родителей одинаковые методы. Какой из них будет наследоваться ребенком?
> Но это уже тема сложнее, и не здесь ее рассказывать.

В этот раз ты услышал шаркающие шаги за спиной (как будто сделанные специально, чтобы их услышали заранее), и, повернувшись,
увидел главврача.

> Уже прочитал о наследовании? Немного похоже на наследование генов в реальной жизни, не правда ли?
> 
> Давай закрепим на практике: создай два класса `DirectoryHandler` и `FileHandler`, которые будут наследоваться от класса `FileSystemElementHandler`.
> Один будет для работы с папками, другой — для работы с файлами. Пусть в первом классе будет скрытый метод — получить содержание папки,
> а во втором скрытый метод — получить расширение файла + методы для чтения и записи. При этом пусть все скрытые методы пусть вызываются в методах
> `__init__`, а их результат записывается в атрибуты. И не забудь вызвать `__init__` родительского класса!

### Задание 2

Итак, ты решаешь начать с класса для работы с папками. Получается, что тебе требуется:
1. В файле *src/handler_2_directory.py* создать класс `DirectoryHandler`, который должен наследоваться от класса `FileSystemElementHandler` 
(при этом вместо копирования этого класса из другого файла лучше использовать импорт). В классе `DirectoryHandler` создать:
    - метод `__init__`, который принимает один аргумент — путь к файлу/папке. Внутри метода вызвать метод `__init__` родителя. 
Далее, с помощью атрибутов объекта (полученных от родителя) проверить, существует ли элемент по переданному пути и является ли он папкой. 
Если да, то определить два атрибута объекта: `children_files` и `children_directories`, в которые необходимо записывать список имен файлов (с расширениями)
и папок внутри данной папки соответственно (если папок или файлов нет, то присваивать атрибутам пустые списки). 
При этом если по переданному пути не существует такой папки, то записать в эти атрибуты `None`;
    - приватный метод `__get_directory_contents`, который должен возвращать кортеж из двух списков: первый список — это имена файлов (с расширениями) внутри папки, 
второй список — это имена папок внутри папки.
Надо не забыть освежить в памяти, как осуществлять распаковку элементов коллекции в разные переменные (для присваивания элементов кортежа в разные атрибуты).
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_2.py*.
3. Пользователь вводит с клавиатуры путь к папке: `Enter the path to the folder: `.
4. Необходимо создать объект класса `DirectoryHandler` (**в следующих заданиях необходимость создавать объект определенного класса и оперировать его атрибутами прописываться не будет, однако, надеюсь, это становится очевидным**).
5. С помощью атрибутов этого объекта необходимо выводить на экран следующие строки:
    ```
    <путь> - <флаг существования файла> (<тип элемента>)
    Inside <path to folder> are:
    Folders - <list of folder names>
    Files - <list of file names with extensions>
    ``` 
    Примеры вывода:
   - для существующей папки:
    ```
    materials - True (directory)
    Inside materials are:
    Folders - ['files_for_tests']
    Files - ['.gitkeep', 'example_csv.txt', 'example_json.txt', 'example_txt.txt']
    ```
   - для папки с вложенными файлами, но не папками:
    ```
    materials/files_for_tests - True (directory)
    Inside materials/files_for_tests are:
    Folders - []
    Files - ['card.json', 'schedule.csv', 'test.txt']
    ```
   - для файла:
    ```
    materials/example_csv.txt - True (file)
    Inside materials/example_csv.txt are:
    Folders - None
    Files - None
    ```
   - если по этому пути нет сущности:
    ```
    asd - False (None)
    Inside asd are:
    Folders - None
    Files - None
    ```

P.S. Надо не забыть выставить в качестве рабочей папки папку с проектом. Иначе пути будут считываться неправильно.
P.S.S. Все импорты надо писать от рабочей папки, т. е. условно: `from src.handler_1_element import ...`\
P.S.S.S. Все пути надо писать относительно нее с помощью обычной строки (не через `pathlib`).

**Текущие P.S. актуальны для последующих заданий и далее повторяться не будут!**

### Задание 3

Отлично, а теперь то же самое для класса работы с файлами:
1. В файле *src/handler_3_file.py* создать класс `FileHandler`, который должен наследоваться от класса `FileSystemElementHandler` (при этом вместо копирования этого класса из другого файла лучше использовать импорт).
В классе `FileHandler` создать:
    - метод `__init__`, который принимает один аргумент — путь к файлу/папке. Внутри метода вызвать метод `__init__` родителя 
(**вызов `__init__` родителя далее во всех заданиях этого проекта обязателен и больше повторяться не будет**). 
Далее необходимо создать атрибут объекта `file_extension`, который будет хранить расширение файла (**БЕЗ ТОЧКИ**: `'txt'`, `'py'` и т. д.);
    - приватный метод `__get_file_extension`, который возвращает расширение файла (**БЕЗ ТОЧКИ**) и не принимает никаких аргументов (кроме self);
    - метод `read`, который должен считывать и возвращать содержимое файла текстового файла. Метод не принимает никаких аргументов (кроме self) 
и возвращает содержимое в виде одной строки (включая специальные знаки переноса строки и т. д.). Чтение осуществлять так же, как и у обычного текстового файла;
    - метод `write`, который принимает на вход строку и перезаписывает содержимое текстового файла, путь до которого был указан при инициализации объекта класса. 
При этом если текстовый файл по заданному пути не существует, то метод создает его и записывает туда переданную строку. Запись осуществлять так же, как и в обычный текстовый файл.
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_3.py*.
3. Пользователь вводит с клавиатуры:
   - `Enter the path to the file to read: ` — путь к файлу, который надо прочитать;
   - `Enter the path to the file to be written to: ` — путь к файлу, в который надо записать текст.
4. После первого ввода необходимо осуществить следующий вывод, а только потом запрашивать второй ввод:
    ```
    <путь> - <флаг существования файла> (<тип элемента>)
    File extension - <расширение без точки>
    <прочитанное содержимое файла>
    ``` 
    Пример для файла — *materials/files_for_tests/test.txt*:
    ```
    materials/files_for_tests/test.txt - True (file)
    File extension - txt
    Test line
    ```
5. После этого вывода необходимо осуществить ввод пути к текстовому файлу, в который необходимо записать следующий текст: `Test line`.
На экран выводить ничего не нужно. По заданному пути должен создаться файл, содержащий текст: `Test line`.
Передать для записи тестовую строку можно прямо в коде, не вводя ее с клавиатуры.

P.S. Все тестирования записи в файл осуществлять в папке *src/*. В папку *materials/* ничего не записывать!

## Chapter IV

### Полиморфизм

> Последний основной принцип — это **полиморфизм**. Он немного сложнее для понимания, но смысл такой: например, нужно создать один метод,
> который называется одинаково у разных классов и делает одно и то же, но просто по-разному. Как пример, можно взять магический метод
> `__len__`, который есть у всех встроенных классов, описывающих коллекции: строки, списки, словари и т. д.
> ```python
> a = {1: '1', 2: '2'}
> print(a.__len__())
> b = [1, 2, 3]
> print(b.__len__())
> c = '12345'
> print(c.__len__())
> ```
> Метод называется одинаково, по сути, делает одно и то же — считывает длину коллекции, но для каждого типа делает он это по-разному.
> Для словарей — это кол-во ключей, для списка — кол-во элементов, для строки — кол-во символов.
> 
> Это полиморфизм в одном из его смыслов. Однако он может выражаться и по-другому. Вернемся к примеру с кошками:
> ```python
> class Animal:
>   def __init__(self, kind):
>       self.kind = kind
> 
>   def eat(self, meal):
>       print(f'Мммм, какая вкусная еда - {meal}')
> 
> class Cat(Animal):
>   def __init__(self, kind, name):
>       super().__init__(kind)
>       self.name = name
> ```
> Как я уже говорил, наследование в ООП очень похоже на наследование в реальной жизни. В реальной жизни мы можем наследовать что-то
> от родителей полностью, например, манеру говорить, а что-то делать по-другому, например, воспитывать детей.
> Само действие — воспитывать детей — есть и у родителей, и у детей. Однако дети могут изменить составляющую этого действия
> или, если говорить в терминах ООП, **переопределить**.
> 
> Вернемся к кошкам. Класс `Animal` имеет метод `eat`, отвечающий за процесс поедания. Класс `Cat` может взять и переопределить
> данный метод, то есть кошка тоже будет есть, но **по-другому**. То есть:
> ```python
> class Animal:
>   def __init__(self, kind):
>       self.kind = kind
> 
>   def eat(self, meal):
>       print(f'Мммм, какая вкусная еда - {meal}')
> 
> class Cat(Animal):
>   def __init__(self, kind, name):
>       super().__init__(kind)
>       self.name = name
>   
>   def eat(self, meal):
>       print(f'И это все?! Почему так мало - {meal}? Ты хочешь, чтобы я умер с голоду?! И я вообще, я вижу дно миски! Это не приемлемо!')
> ```
> 
> Так может выражаться полиморфизм в наследовании, то есть в переопределении класса родителя.
> 
> Можно задаться вопросом: а зачем это нужно, если можно сразу тогда реализовать метод в дочернем классе и не реализовывать у родителя?
> Ответ простой: представь, что большинство животных одинаково едят, и классы, которые их описывают, будут просто наследовать общий
> для всех животных метод `eat`, но для некоторых животных он будет отличаться, то есть переопределяться.

### Задание 4

> Постигаешь полиморфизм? Так, давай сразу на примерах. Покажи мне код предыдущего задания. Ага, угу, все понятно.
> Смотри, твое чтение и запись предназначены только для текстовых файлов. Создай класс `JSONFileHandler` для работы с json-файлами, который будет наследовать от
> `FileHandler`, и переопредели в нем методы `read` и `write`, учитывая специфику чтения и записи для этого типа файлов.
>> **Главврач**

Ты чешешь репу, напрягаешь извилины и рожаешь следующий план:
1. В файле *src/handler_4_json.py* создать класс `JSONFileHandler`, который должен наследоваться от класса `FileHandler`.
В классе `JSONFileHandler` создать:
    - метод `__init__`, дополнительные аргументы создавать в нем не нужно;
    - переопределить метод `read`, который должен считывать и возвращать содержимое файла. Метод не принимает никаких аргументов (кроме self) и возвращает содержимое в виде словаря;
    - переопределить метод `write`, принимающий на вход словарь и перезаписывающий содержимое файла, путь до которого был указан при инициализации объекта класса. При этом если файл по заданному пути не существует, то метод создает его и записывает туда переданный словарь.
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_4.py*.
3. Пользователь вводит с клавиатуры:
   - `Enter the path to the json file to read: ` — путь к файлу, который надо прочитать;
   - `Enter the path to the json file to be written to: ` — путь к файлу, который еще не существует, но будет создан при записи в него.
4. После первого ввода необходимо осуществить следующий вывод (обрабатывать вывод в красивом виде не нужно), а только потом запрашивать второй ввод:
    ```
    <путь> - <флаг существования файла> (<тип элемента>)
    File extension - <расширение без точки>
    <прочитанное содержимое файла>
    ``` 
    Пример для файла — *materials/files_for_tests/card.json*:
    ```
    materials/files_for_tests/card.json - True (file)
    File extension - json
    {'Surname': 'Sidorova', 'Name': 'Svetlana', 'Patronymic': 'Sergeevna', 'Date of birth': '1987-03-11', 'Sex': 'W'}
    ```
5. После этого вывода необходимо осуществить ввод пути к json-файлу, в который необходимо записать следующий словарь: `{1: 'Test 1', 2: 'Test 2'}`.
На экран выводить ничего не нужно. По заданному пути должен создаться файл. Содержимое должно быть записано в красивом виде с 4 отступами:
    ```
    {
        "1": "Test 1",
        "2": "Test 2"
    }
    ```
    Передать для записи тестовый словарь можно прямо в коде, не вводя его с клавиатуры.

P.S. Все тестирования записи в файл осуществлять в папке *src/*. В папку *materials/* ничего не записывать!

## Chapter V

### Абстрактные классы

Файл с теорией все еще не закончился, пора вернуться к нему.

> Переопределение — это очень полезный механизм. К нему можно подойти немного по-другому. Можно создать класс, который будет
> содержать методы, которые необходимо ОБЯЗАТЕЛЬНО реализовать в классах потомках. То есть программист может сказать, что у этого класса 
> есть два обязательных метода, допустим, чтение и запись. И любой потомок, который наследуется от этого класса, должен переопределить
> эти методы. Такие классы называются **абстрактными** классами. На примере животных:
> ```python
> from abc import ABC, abstractmethod 
>
> class Animal(ABC):
>   @abstractmethod
>   def eat(self):
>       pass
> 
>   @abstractmethod
>   def drink(self):
>       pass
> 
> class Cat(Animal):
>   def __init__(self, name):
>       self.name = name
>   
>   def eat(self):
>       print('Ест с презрением к человеку')
> 
>   def drink(self):
>       print('Пьет, как эстет')
> 
> class Dog(Animal):
>   def __init__(self, name):
>       self.name = name
>   
>   def eat(self):
>       print('Ест с любовью к человеку')
> 
>   def drink(self):
>       print('Пьет, как в последний раз')
> ```
> Как, что, где и почему так работает, попробуй разобраться сам. Сделаю лишь пару ремарок:
> - чтобы сделать класс абстрактным, нужно отнаследовать его от класса `ABC`, импортированного из модуля `abc`;
> - строка `@abstractmethod` над функцией показывает, что метод относится к абстрактным, то есть его необходимо будет обязательно определить у всех потомков данного класса;
> - от абстрактного класса нельзя инициализировать объект, т. е. это просто обязательный для исполнения шаблон для потомков этого класса;
> - попробуй создать объект от класса, который наследует от абстрактного и в котором не переопределены все абстрактные методы из класса родителя.

### Задание 5

Ты решаешь попробовать еще больше расширить написанный тобой функционал. Ведь сейчас ты можешь читать только текстовые файлы с помощью методов класса `FileHandler` и json-файлы с помощью класса `JSONFileHandler`. Почему бы не расширить это и для csv-файлов?
И неплохо было бы вынести логику для текстовых файлов в отдельный класс, а класс `FileHandler` сделать абстрактным с обязательными методами `read` и `write`. Хм, однако хочется сохранить и наследование от класса `FileSystemElementHandler`, чтобы не терять его возможности. Возможно, здесь поможет множественное наследование?

Получается, что необходимо сделать следующее:
1. В файле *src/handler_5_file.py* переписать класс `FileHandler`, чтобы он наследовался от класса `FileSystemElementHandler` и в то же время был бы абстрактным. 
При этом методы `read` и `write` необходимо сделать абстрактными методами без конкретной реализации. 
Метод `read` не должен принимать никаких аргументов (кроме self), а метод `write` должен принимать один аргумент (помимо self) с содержанием того, что будет записано в файл.
2. В файлах *src/handler_5_txt.py*, *src/handler_5_json.py* и *src/handler_5_csv.py* реализовать классы `TXTFileHandler`, `JSONFileHandler` и `CSVFileHandler` соответственно. 
Каждый из классов должен наследоваться от нового класса `FileHandler` из файла *src/handler_5_file.py*.
В каждом файле необходимо переопределить методы `read` и `write`.
3. Метод `read` должен считывать и возвращать:
    - строку для txt-файлов;
    - словарь для json-файлов;
    - список списков для csv-файлов.
4. Метод `write` должен принимать на вход:
    - строку для txt-файлов и записывать ее в файл;
    - словарь для json-файлов и записывать его в красивом виде с отступом в 4 пробела (см. пред. задание);
    - список списков для csv-файлов и записывать в csv-файл с разделителем-запятой (см. файл *materials/files_for_tests/schedule.csv*).
5. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_5.py*.
6. Пользователь вводит с клавиатуры:
   - `Enter the path to the csv file to read: ` — путь к файлу, который надо прочитать;
   - `Enter the path to the csv file to be written to: ` — путь к файлу, который еще не существует, но будет создан при записи в него.
7. После первого ввода необходимо осуществить следующий вывод (обрабатывать вывод в красивом виде не нужно), а только потом запрашивать второй ввод:
    ```
    <путь> - <флаг существования файла> (<тип элемента>)
    File extension - <расширение без точки>
    <прочитанное содержимое файла>
    ``` 
    Пример для файла — *materials/files_for_tests/schedule.csv*:
    ```
    materials/files_for_tests/schedule.csv - True (file)
    File extension - csv
    [['Time', 'Patient', 'The patient visited the doctor'], ['08:00', 'Ivanov Ivan Ivanovich', 'No'], ['08:30', 'Petrov Petr Petrovich', 'No'], ['09:00', 'Sidorova Svetlana Sergeevna', 'No'], ['09:30', 'Maximova Elena Petrovna', 'No']]
    ```
8. После этого вывода необходимо осуществить ввод пути к несуществующему csv файлу, в который необходимо записать следующий список списков: `[['a', 'b'], [0, 1], [2, 3]]`.
На экран выводить ничего не нужно. По заданному пути должен создаться файл. Содержимое должно быть записано в следующем виде:
   ```
   a,b
   0,1
   2,3
   
   ```
   Передать для записи тестовый список списков можно прямо в коде, не вводя его с клавиатуры.

P.S. Все тестирования записи в файл осуществлять в папке *src/*. В папку *materials/* ничего не записывать! \
P.S.S. Несмотря на то что в `main` не используются классы  `TXTFileHandler` и `JSONFileHandler`, нужно проверить их работу.
А то вдруг кто-то еще их проверит, кроме тебя...

## Chapter VI

### Методы класса

> Вижу, что ты и без моей подсказки реализовал для каждого вида файла отдельный класс. Молодец! Хвалю! 
> Приятно видеть энтузиазм в молодых глазах.
> 
> Пора дойти до точки в этом проекте с файлами. Хотелось бы получить следующую программу на выходе:
> 1. Я пишу путь к любому файлу.
> 2. Программа проверяет:
>   - есть ли вообще элемент по этому пути;
>   - является ли элемент файлом.
> 3. Если это файл, то определяется его расширение, и, в зависимости от него, используется нужный класс.
> 4. С помощью этого класса считывается содержимое файла и выводится на экран.
> 
> Только давай, наверное, сделаем красивый вывод на экран. Добавь еще один абстрактный метод `pretty_print` в класс для работы с файлами.
> Ну и переопредели их в дочерних классах в зависимости от расширения.
> 
> И еще одно: мне не нравится, что в классе `FileSystemElementHandler` методы для проверки существования элемента и определения его типа приватные.
> Да-да, я сам тебя просил их такими сделать, я помню. Но мои идеи, как вода — переменчивы. Оставлять эти методы приватными не очень
> удобно, так как чтобы их вызвать, нужно обязательно создавать объект данного класса.
> 
> Существуют так называемые **методы класса**. Не путай с методами объектов. Методы класса можно вызывать как через объект класса,
> так и напрямую через сам класс. Дай листочек, я набросаю пример. Представь, что в классе `Example` есть метод класса `get`:
> ```python
> class Example:
>   ...
> 
> a = Example()
> b = a.get()
> c = Example.get()
> ```
> А как задаются методы класса, ты уже сам поищи. В общем, я бы хотел, чтобы ты переделал эти приватные методы в методы класса.
> И потом использовал бы эти методы через вызов у класса в основной программе.
> 
> А знаешь, сделай то же самое с приватным методом `__get_file_extension` в классе `FileHandler`. Кажется, что так будет логично.

### Задание 6

Если все собрать вместе и немного уточнить, то получается, что ты должен:
1. В файле *src/handler_6_element.py* переписать класс `FileSystemElementHandler`:
    - вместо приватного метода `__element_exists` сделать метод класса `element_exists`, который принимает один аргумент `path` (не считая 1 аргумента cls).
Логику оставить такой же, единственное изменение, что путь до файла теперь берется из аргумента, а не через self, как раньше;
    - вместо приватного метода `__get_element_type` сделать метод класса `get_element_type`, который принимает один аргумент `path` (не считая 1 аргумента cls).
Логику оставить такой же, единственное изменение, что путь до файла теперь берется из аргумента, а не через self, как раньше;
    - переписать в `__init__` вызов этих методов;
    - остальное оставить, как в файле *src/handler_1_element*.
2. В файле *src/handler_6_file.py* переписать класс `FileHandler` (не забыть наследовать его от обновленного класса), в который:
    - добавить абстрактный метод `pretty_print`, который принимает на вход один аргумент (кроме self) — то, что, собственно, и выводить на экран;
    - вместо приватного метода `__get_file_extension` сделать метод класса `get_file_extension`, который принимает один аргумент `path` (не считая 1 аргумента cls);
    - переписать в `__init__` вызов метода `get_file_extension`;
    - остальное оставив как в *src/handler_5_file.py*.
3. В файлах *src/handler_6_txt.py*, *src/handler_6_json.py* и *src/handler_6_csv.py* реализовать классы `TXTFileHandler`, `JSONFileHandler` и `CSVFileHandler` соответственно 
(не забыв отнаследовать их от нового класса из *src/handler_6_file.py*). В каждом файле необходимо переопределить метод `pretty_print`.
Остальной функционал оставить таким же, как и в предыдущей реализации.
4. Метод `pretty_print` должен:
   - для txt-файлов: принимать на вход строку, сначала выводить на экран `Contents of the text file:`, а после со следующей строки само содержимое;
   - для json-файлов: принимать на вход словарь, сначала выводить на экран `Contents of the json file:`, а после со следующей строки выводить его в том же виде, 
как он записан в *materials/files_for_tests/card.json* (с отступом в 4 пробела);
   - для csv-файлов: принимать на вход список списков, сначала выводить на экран `Contents of the csv file:`, 
а после со следующей строки отображать его с помощью `tabulate` и формата `github`, где первый список — это заголовки.
5. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_6.py*.
6. Пользователь вводит с клавиатуры путь к элементу: `Enter the path to the file to read: `.
7. Программа должна:
   - ЕСЛИ элемента, путь до которого введен с клавиатуры, не существует, выводить на экран фразу: `There is no such file!` и **ЗАВЕРШАТЬСЯ**;
   - ЕСЛИ элемент, путь до которого введен с клавиатуры, существует, но является папкой, выводить на экран фразу: `This is not a file, but a folder!` и **ЗАВЕРШАТЬСЯ**;
   - для двух пунктов выше проверку осуществлять с помощью методов класса через сам класс;
   - в остальных случаях необходимо проверять расширение файла и с помощью метода `pretty_print`, подходящего для этого расширения класса,
выводить на экран содержимое.

> Пример работы программы можно посмотреть тут для:
> - *materials/example_txt.txt*;
> - *materials/example_csv.txt*;
> - *materials/example_json.txt*.
>> **Голос свыше**

## Chapter VII

### Задание 7

Фух, тяжелый день, остается только запушить все наработки в GitLab в ветку `develop`, включая абсолютно все файлы *.py* из папки *src/*.
Пушить файлы *.csv*, *.json* и *.txt*, которые могли возникнуть в ходе тестирований, не нужно.

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
