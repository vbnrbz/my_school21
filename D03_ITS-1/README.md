# Понимание и обработка исключений

## Аннотация

Данный проект позволит тебе улучшить твой навык работы с исключениями (ошибками), умение их читать, а также обрабатывать и вызывать.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Чтение и исправление исключений](#чтение-и-исправление-исключений) \
    2.2. [Задание 1](#задание-1) \
    2.3. [Задание 2](#задание-2) \
    2.4. [Задание 3](#задание-3) \
    2.5. [Задание 4](#задание-4)
3. [Chapter III](#chapter-iii) \
    3.1. [Обработка исключений](#обработка-исключений) \
    3.2. [Задание 5](#задание-5) \
    3.3. [Задание 6](#задание-6)
4. [Chapter IV](#chapter-iv) \
    4.1. [Ручное возбуждение исключений](#ручное-возбуждение-исключений) \
    4.2. [Задание 7](#задание-7)
5. [Chapter V](#chapter-v) \
    5.1. [Заключение](#заключение) \
    5.2. [Задание 8](#задание-8)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. 

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер: 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

Ты просыпаешься утром и вспоминаешь, что сегодня выходной, то есть в поликлинику идти не надо. Чем бы заняться? У тебя запланирована встреча с друзьями на вечер, но утро и день совершенно свободны. Ты тратишь время на ежедневную утреннюю рутину, просматриваешь пару смешных видосов. Хм, чем бы заняться дальше? И тут тебе в голову приходит мысль:

> Точно, я же захватил на флешке все записи админа. Может, поискать в них что-нибудь интересное?
>> **Твои мысли**

## Chapter II

### Чтение и исправление исключений

Ты открываешь список файлов и просматриваешь их названия. Ты видишь файлы: *Бесят ошибки?! Сюдааааа.txt*. 
Вчера ты действительно настрадался от этих ошибок. Любой шаг в сторону — ошибка! Какой-то очень принципиальный язык программирования...
Ты открываешь файл.

> Одно из важнейших умений любого программиста — умение работать с ошибками, которые у тебя постоянно всплывают.
> Метод работы «написал код, выполнил, получил ошибку, исправил ошибку, выполнил, получил новую ошибку и т. д.» никто не отменял.
> Это главный принцип работы любого программиста. Умение гуглить и читать/исправлять ошибки — вот те два главных кита, на которых держится черепаха эффективности разработчика.
> 
> Ниже приведен пример кода с ошибкой (слева в файле указана нумерация строк). В Python ошибки называются **исключениями**.
> ```python
> 1 # Пример кода с ошибкой
> 2 
> 3 a = 0
> 4
> 5 print(1 / 0)
> 6
> ```
> При его выполнении ты получишь следующую ошибку:
> ```
> Traceback (most recent call last):
> File "/home/previous_admin/project_3_handling_exceptions/src/example_error.py", line 5, in <module>
>    print(1 / 0)
>         ~~^~~
> ZeroDivisionError: division by zero
> ```
> Давай разберемся с ней. В первую очередь тебе нужно смотреть на последнюю строчку.
> 
> **ZeroDivisionError: division by zero**
> 
> **ZeroDivisionError** — это имя ошибки. Считай, что именно его нужно гуглить в первую очередь, когда ты не знаешь, что это за ошибка.
> Однако перед тем как гуглить, прочитай текст после двоеточия: «**division by zero**». Если у тебя плохо с английским, не стесняйся вставлять эту строчку в гугл-переводчик.
> В ней написано: «деление на ноль». И действительно, математика запрещает делить на ноль (вообще, более продвинутые математики могут это делать, но не будем здесь об этом).
> 
> Далее, как только ты понял, **ЧТО** за исключение выпало, нужно понять, **ГДЕ** это случилось.
> 
> **File "/home/previous_admin/project_3_handling_exceptions/src/example_error.py", line 5, in <module>**
> 
> Эта строчка показывает:
> - в каком файле встретилась ошибка: после слова **File** указан **абсолютный путь** до этого файла — «**/home/previous_admin/project_3_handling_exceptions/src/example_error.py**»;
> - на какой строке встретилась ошибка: номер строки с ошибкой указан после слова **line**, в данном примере номер линии с ошибкой — 5.
> 
> Ну и следующая строчка в ошибке **print(1 / 0)** часто показывает, в каком конкретно куске кода выпало исключение.
> 
> Запомни, когда твоя программа падает с ошибкой, ты должен сделать следующее:
> - прочитать ошибку;
> - понять, **ЧТО** это за ошибка, если не знаешь — гугли;
> - понять, **ГДЕ** эта ошибка встречается;
> - поправить конкретный кусок кода, где встретилась ошибка.
> 
> При этом ты НЕ должен:
> - не читая ошибку, бежать и смотреть свой основной код;
> - не читая ошибку, пытаться что-то поправить;
> - не читая ошибку, перезапускать программу миллион раз, надеясь, что случится чудо;
> - не читая ошибку, падать на клавиатуру, кататься по ней лицом и молиться, что рандомные нажатия спасут ситуацию.
> 
> Я тебе подготовил ряд заданий, которые помогут тебе научиться читать и работать с исключениями. 
> И не путайся: слово исключение в Python встречается чаще, чем ошибка.

### Задание 1

> В файле *src/task_1.py* представлено твое первое задание. В этом и последующем заданиях тебе будет даваться нерабочий код, который выплевывает исключения.
> Данный код делает какие-то арифметические операции и выводит результат на экран.
> Твоя задача — поправить код и сделать его рабочим (то есть он должен выполняться без ошибок).
> Изучи все операции, запиши их на листочке, вычисли и проверь результат.
>
> Кстати, обрати внимание, что в этом задании я тебе привел пример **комментариев** в коде. Комментарии разработчики оставляют для себя
> и других разработчиков. Поверь, через пару дней ты уже забудешь, что твой код делает. Комментарии очень важны! Старайся не пренебрегать ими.
> 
> P.S. Кстати, умные **IDE** (среды разработки, как PyCharm) часто и сами подчеркивают места с ошибками. 
> Однако это не заменит чтение ошибок!!!

### Задание 2

> В файле *src/task_2.py* твое второе задание. Обрати внимание, что здесь представлены разные способы задавания строк (через разные виды кавычек).
> Код просто объявляет пару, другую строку, делает операции с ними и выводит на экран две из них. Твоя задача все та же: поправить ошибки, а также ИЗУЧИТЬ операции на строках (`+` и `*`), посмотреть, что они делают и какой результат дают.

### Задание 3

> В файле *src/task_3.py* твое третье задание. В нем задается строка, и с ней осуществляются какие-то операции, применяются какие-то методы и даже чуток срезов!
> Ну и в конце результат этих операций выводится на экран. 
> 
> И как-то здесь уже больше подчеркиваний от PyCharm, не считаешь? На самом деле PyCharm
> подчеркивает не только ошибки, но и плохой **стиль кода** (про него я тебе расскажу потом). Подчеркивания кода от IDE — это полезно, но не самое главное.

### Задание 4

> В файле *src/task_4.py* твое четвертое задание. Хм, кажется, ты уже можешь почувствовать закономерность в первом предложении.
> Ну да ладно, в этом задании с клавиатуры нужно ввести число. Но ты же не всегда должен следовать правилам, не так ли?
> Даешь хаос! Попробуй ввести строку вместо числа.
> 
> Ух, ну ты и бунтарь, конечно. А теперь сбалансируй хаос и следуй тому, что тебя просят в программе, т. е. введи число.

## Chapter III

### Обработка исключений

> Надеюсь, ты понял, как нужно действовать в случае возникновения исключений.
> 
> Однако бывают моменты, когда исключения будут выпадать в тех случаях, когда не все зависит от тебя. Например, твоя программа берет число 10
> и делит его на число, которое пользователь вводит с клавиатуры. Никто не запретит пользователю ввести ноль (если, конечно, не стоять с палкой у него за спиной).
> И БАЦ, ошибка деления на ноль.
> 
> Да, в этом случае можно проверять с помощью `if`, является ли введенное пользователем числом и не нулем.
> Но бывают случаи, когда исключения с помощью `if` не поймать. Допустим, какой-то сайт под капотом идет в базу данных и пытается найти там какую-то информацию.
> В этот момент отваливается сеть. Через какое-то время код выдаст исключение, связанное с **timeout**, то есть условно 10 секунд код пытался связаться с базой данных,
> не смог и выдает ошибку — время на связь с базой данных кончилось! Если эту ошибку не обработать, то сайт упадет. Вместо этого хочется просто выдавать клиенту сообщение: «Какие-то проблемы, попробуйте через пару минут».
> 
> Так вот, эта обработка называется **обработка исключений**. В Python она реализована через блок `try-except`.
> Следующие задания будут направлены на понимание обработки исключений с помощью этого блока. При этом блоков **except** может быть несколько.

### Задание 5

> В файле *src/task_5.py* представлено твое пятое задание.\
> Во-первых, не удивляйся, что в коде какие-то странные ошибки. Я все еще пытаюсь показать тебе разные виды исключений в Питоне.\
> Во-вторых, данная программа просит ввести число от -10 до 10 (надеюсь на твою честность при вводе). А далее делает **что-то**.
> Вот это я, конечно, интриган. Разберись сам, что происходит в коде. Как только он у тебя заработает, запусти его столько раз, 
> сколько потребуется, чтобы появилось исключение (не переживай, на какой-то раз оно точно появится).
> 
> Как только ты поймаешь исключение, обработай его с помощью блока try-except. Я хочу, чтобы вместо исключения на экран выводилось сообщение:
> `You can not take the root of a negative number!`.

### Задание 6

> В файле... А я думаю, что ты сам догадаешься, в каком файле находится твое шестое задание. Ну ладно, вот твой файл — *src/task_6.py*.\
> В данном задании демонстрируется работа **индексов** в строках. По доброй традиции код содержит ошибку, которая не позволит тебе его полностью выполнить.\
> Как только ты поправишь эту ошибку, может сложиться впечатление, что все ОК. Однако в программировании есть простое правило: если твой клиент МОЖЕТ когда-нибудь сделать что-то не так,
> он обязательно это СДЕЛАЕТ. Так, например, он может ввести вместо индекса 1, 2, 3 индекс 100! Или даже 1000!
> Попробуй сделать это — получишь исключение. Вот его и нужно будет обработать.
> 
> А теперь я признаюсь, что скрыл от тебя кое-что. Блок `try-except` может быть расширен. Ключевые слова `try` и `except` действительно обязательны в этом блоке.
> Однако есть также необязательные ключевые слова `else` и `finally`. Прочитай, что они делают.
> 
> Вернемся к тому, КАК обработать эту ошибку:
> - ЕСЛИ код выполнился без исключений, то пусть выводится строка: `And yes, such an index really did exist!`. Но запиши ее внутри else.
> - ЕСЛИ код внутри try выплюнул исключение, то пусть выдает на экран строку: `There is no such index in this line!`.
> - В конце кода ВСЕГДА пусть выводит строку: `End!`, используй для этого дополнительное ключевое слово этого блока.
> 
> Обращу внимание еще раз: всю обработку нужно осуществить внутри расширенного блока `try-except-else-finally`.
> 
> P.S. Несмотря на то что знать про `else` и `finally` необходимо в блоке `try-except`, в реальной жизни они применяются не очень часто.
> Поэтому не удивляйся вопросам в своей голове — а нафига они вообще нужны?! Редко — нужны, но в большинстве случаев у программистов тот же вопрос.

## Chapter IV

### Ручное возбуждение исключений

> Может прозвучать довольно странно, но иногда тебе нужно будет самому вызывать исключения, чтобы программа падала с ошибкой. 
> 
> Допустим, при делении на ноль ты хочешь, что программа падала с ошибкой, однако перед этим выводила на экран логин того, кто ввел этот ноль (если есть авторизация).
> Страна ведь должна знать своих героев в лицо?! Тогда ты можешь в блоке except вывести на экран логин, а после этого уже возбудить ту же самую ошибку `ZeroDivisionError`.
> 
> Ошибка вызывается с помощью ключевого слова `raise`, далее идет имя ошибки. При этом в скобках ты можешь передать текст, который будет отображаться при появлении этого исключения.
> 
> Инициирование ошибки — это всегда прерывание программы.

### Задание 7

> Итак, твое последнее испытание на ошибки ждет в файле *src/task_7.py*. Программа в этом файле показывает тебе, как работают срезы в строках.
> Как они записываются, ты можешь посмотреть в коде, а что выводят — посмотреть на экране вывода. На самом деле срезы в некоторых моментах работают не интуитивно.
> Попробуй, например, ввести в качестве первого индекса 1000, а второго — 10. Программа выполнилась! Ничего не упало... Просто в качестве среза вернулась пустая строка.
> 
> Давай попробуем добавить чуть больше логики в срезы. Пусть программа инициирует исключение `IndexError("There is some kind of crap going on with your indexes!")` при следующих условиях:
> - ЕСЛИ первый индекс среза БОЛЬШЕ ИЛИ РАВЕН второму индексу среза;
>
> ИЛИ
> 
> - ЕСЛИ первый индекс среза БОЛЬШЕ длины строки;
> 
> ИЛИ
> 
> - ЕСЛИ второй индекс среза БОЛЬШЕ длины строки;
>
> При этом условия выше справедливы лишь тогда, когда введенные индексы — это числа. Учти случаи (условия для них допиши сам), когда пользователь может не вводить индекс и 
> передавать вместо первого и/или второго индексов пустую строку в переменные (то есть просто нажимать Enter).
> 
> P.S. При этом программа пусть учитывает только те случаи, когда пользователь ввел с клавиатуры либо число, либо сразу нажал Enter.
> Не учитывай случаи, когда пользователь может ввести буквы или другие символы.

## Chapter V

### Заключение

Звонит будильник. Ты поднимаешь глаза от компьютера, смотришь на время и видишь 7 часов вечера. Кажется, пора закругляться, друзья ждут!
Ты ощущаешь приятное чувство. Выходной, а ты не только отдохнешь, но и уже сделал полезное дело.
По результатам сегодняшнего дня ты решаешь сделать для себя следующие выводы:
- Частые ошибки (или, как они называются в Питоне, **исключения**) — это нормальная часть работы.
- Для эффективной работы нужно уметь читать исключения.
- Если не хочется, чтобы программа прерывалась на каком-то исключении, можно обработать его с помощью блока `try-except`.
- В блоке `try-except` есть необязательные части `else` и `finally`, которые используются нечасто, но лучше не забывать про их существование.
- Если тебе захочется, то ты можешь сам вызвать исключение с помощью ключевого слова `raise`.

### Задание 8

Чуть не забыл, что нужно залить (**запушить**) свои наработки на GitLab в ветку `develop`.

Будильник звонит второй раз. Так, всё, это означает, что уже пора выходить. Продолжишь в следующий раз!

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
