# Авторизация и JWT

Аннотация: \
Данный проект научит тебя работать с ролями пользователей, API, авторизацией и JWT-токенами.

## Содержание

1. [Chapter I](#chapter-i) \
   1.1. [Рекомендации к проекту](#рекомендации-к-проекту)
2. [Chapter II](#chapter-ii) \
   2.1. [Задание 1](#задание-1-обновление-структуры-приложения) \
   2.2. [Задание 2](#задание-2-микросервис-авторизации) \
   2.3. [Задание 3](#задание-3-модели-пользователей-в-микросервисе-авторизации) \
   2.4. [Задание 4](#задание-4-регистрация-пользователей-в-микросервисе-авторизации) \
   2.5. [Задание 5](#задание-5-роуты-токенов-и-регистрации) \
   2.6. [Задание 6](#задание-6-личная-страница-пользователя) \
   2.7. [Бонусное задание 7](#бонусное-задание-7-закрытый-доступ-к-странице)

## Введение

Придя сегодня в Лабораторию, ты еще долго рассматривал присланную тебе фотографию. Главврач, который должен быть в командировке, загадочным образом... документировал макулатуру в школе сына Вениамина и Клариссы? Почему? Зачем? У тебя начало складываться смутное впечатление, что за всем этим что-то стоит — и ты по странному стечению обстоятельств оказался в центре происходящего. Впрочем, как говорится, случайности неслучайны... 

Не успел ты додумать эту мысль, как тебе поступил звонок. Это была Кларисса.

>— Добрый день, мы посмотрели вашу БД и остались в полном восторге! Какая же красота, просто великолепно. 
>>**Кларисса**

>— Спасибо.
>>**Стажер**

Время работы с Главврачом научило тебя подозревать худшее даже в самом безобидном разговоре. Так и оказалось:

>— Но мы подумали-подумали и поняли, что хотелось бы, чтобы наши пациенты могли создавать себе аккаунты, раз уж они все равно есть в базе. Да и нам проще их будет отслеживать по приложению. Такое сможете сделать?
>>**Кларисса**

Ты решил ответить честно, чтобы от тебя не ожидали многого: «Никогда в жизни». К сожалению, Кларисса обладала потрясающей способностью пропускать мимо ушей всю ненужную информацию и слышать то, что ей хочется.

>— Вот и отлично, будем очень ждать ваших наработок. 
>>**Кларисса**

>— Но ведь я...
>>**Стажер**

>— Ой, тут такая связь плохая, пш-пш, вас... слышно, пш-пш, нав... туннель...
>>**Кларисса**

И звонок прервался. 

>— ...
>>**Стажер**

## Chapter I

### Рекомендации к проекту

Как учиться в «Школе 21»:

- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай.
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками.
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла.
- Если ты на чем-то застрял и кажется, что все уже перепробовал, но по-прежнему непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову, и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить.

Как работать с проектом:
- Вся работа выполняется на виртуальной машине. Для начала ее нужно настроить, воспользовавшись [инструкцией](https://applicant.21-school.ru/guide_vm_med). Далее запустить виртуальную машину и продолжать выполнять работу над проектом там.
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.

Дисклеймер:

- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

## Chapter II

Тебе уже удалось создать полноценное приложение, где есть постоянное хранилище (БД), формы и CRUD для пациентов и врачей. Настало время научиться обеспечивать аутентификацию (логин/пароль) и ролевую модель, чтобы, например, ограничивать доступ к некоторым функциям приложения. А еще тебе пора узнать о микросервисной архитектуре.

❗ Ты можешь скопировать приложение из предыдущего проекта и продолжать работу над ним или взять готовое приложение `med_center_project` и заниматься проектом авторизации. Не забудь создать своего суперюзера.

### Задание 1. Обновление структуры приложения

В мире разработки есть концепция микросервисов. В этой концепции каждый микросервис занимается своим делом и ничего не знает о других — он самодостаточен, и ему только нужно получать или отдавать данные, ради обработки которых он был создан. Очень часто создают отдельный микросервис авторизации — это означает, что остальные сервисы не знают логинов/паролей пользователей, а доверяют сервису авторизации, который удостоверяется, что пользователь ввел корректные логин и пароль.

_Преимущество подхода — можно соединять приложения, написанные на разных технологиях. Например, ничто не помешает иметь сервис авторизации на Go (Java, C#), а основное приложение на Python (или, опять же, на других технологиях), общаясь по REST API. Более глубоко REST будет рассмотрен в следующем проекте, а сейчас воспользуйся минимумом, который нужен для решения проекта._

Для начала проверь структуру проекта:

1. Положи проект `med_center_project` в папку src.
2. Разберись в том, как оно работает и какие необходимы данные для создания пользователей.
3. Создай новый проект (`auth_service_project`) в src и приложение (`accounts`).
4. Настрой в нем новое виртуальное окружение.

### Задание 2. Микросервис авторизации

1. Установи следующие зависимости:

    - django;
    - djangorestframework;
    - djangorestframework-simplejwt;
    - PyJWT;
    - requests.

2. Зафиксируй их в `requirements.txt`.
3. Не забудь добавить их в `INSTALLED_APPS`.
4. Добавь настройки `DRF` и `JWT`.

    **JWT (JSON Web Token)** — это открытый стандарт для безопасной передачи данных между сторонами в виде JSON-объекта. Он часто используется для аутентификации и авторизации пользователей.

    Структура JWT:
    - **заголовок (header)**: содержит тип токена и алгоритм шифрования;
    - **полезная нагрузка (payload)**: содержит данные о пользователе (идентификатор, роль и др.);
    - **подпись (signature)**: используется для проверки подлинности токена.

    Преимущества JWT:
    - не требует хранения сессий на сервере (stateless);
    - может содержать полезную информацию о пользователе;
    - может использоваться в микросервисной архитектуре.

5. Скопируй секретный ключ из `med_center_project`.

_Подсказка: теги `REST_FRAMEWORK = {}` и `SIMPLE_JWT = {}`._

**Важно**: для реального проекта секретный ключ следует хранить в переменных окружения, а не в коде. Изучи, как принято хранить ключи.

### Задание 3. Модели пользователей в микросервисе авторизации

1. Создай кастомную модель пользователя: `class User(AbstractUser)`.
2. В ней опиши две роли: `patient` и `doctor` (пусть это будет `models.CharField`).
3. Укажи в настройках кастомную модель пользователя `AUTH_USER_MODEL`.

В Django параметр `AUTH_USER_MODEL` в `settings.py` позволяет указать кастомную модель пользователя вместо стандартной. Формат указания — `'app_name.ModelName'` (например, `'accounts.User'`). Это нужно делать до первой миграции, иначе возникнут проблемы с внешними ключами. Кастомная модель пользователя дает гибкость в расширении стандартной модели User дополнительными полями и функциональностями.

**Важно**: изучи работу сериализаторов.

Сериализаторы в Django играют ключевую роль при работе с API и микросервисами. Они выполняют следующие функции:

- преобразование данных,
- валидация данных,
- создание и обновление объектов.

В микросервисной архитектуре сериализаторы особенно важны, поскольку:

- обеспечивают единый формат данных,
- скрывают внутреннюю структуру данных,
- контролируют доступ к данным.

### Задание 4. Регистрация пользователей в микросервисе авторизации

В этом задании тебе предстоит сделать сложную регистрацию пользователя: ты будешь регистрировать пользователя в сервисе авторизации, передавать остальную информацию (для врача — `ФИО` и `специальность`, для пациента — `ФИО`, `ДР`) в сервис медцентра и в нем обрабатывать эту информацию, создавая не пользователя, а экземпляр модели в БД.

1. Создай в `serializers.py` сериализаторы для регистрации доктора и пациента.
2. Добавь кастомизированный сериализатор токена, чтобы в него добавлялось поле `role`.
3. Сериализатор занимается созданием пользователя в сервисе авторизации и отправляет в сервис клиники (эндпоинт `/api/<role>/create/`) сообщение для регистрации пользователя.

    **Представления (views)** в Django — это функции или классы, обрабатывающие HTTP-запросы. **Эндпоинты** — это URL-адреса, по которым доступны представления. В нашем случае вьюхи будут обрабатывать POST-запросы для регистрации пользователей. В представлении данные из запроса передаются сериализатору для валидации, сохраняются в БД, а затем будет возвращаться соответствующий ответ (успех/неуспех).

4. Добавь вьюхи для регистрации пользователей. На оба эндпоинта приходит `POST`-запрос, обработка данных происходит с помощью сериализаторов:
    - `register_doctor` для регистрации доктора;
    - `register_patient` для регистрации пациента.
5. Для обеих вьюх сделай обработку случаев успеха и неуспеха регистрации: возвращай сообщение и код `201` в случае успеха, `400` в случае неуспеха.

_Подсказка: не забывай выполнять миграции при изменении моделей._

### Задание 5. Роуты токенов и регистрации

1. Опиши логику, чтобы в `urls.py` приложения появились:

    - `token/`;
    - `token/refresh/`;
    - `register/doctor/`;
    - `register/patient/`.

    _Для роутов `token` и `token/refresh/` используй `MyTokenObtainPairView` и `TokenRefreshView`._

2. Протестируй, что все работает и токены выдаются. Для этого можно использовать консоль с помощью команды `curl` или обратиться к инструментам с UI — например, Postman.

    **Postman** — это инструмент для тестирования API с графическим интерфейсом, он позволяет отправлять HTTP-запросы на сервер и анализировать ответы. Для проверки JWT создай POST-запрос на эндпоинт авторизации, передав JSON с логином и паролем в теле запроса. В ответе ты получишь access- и refresh-токены, которые можно использовать для авторизованных запросов, передавая их в заголовке Authorization.

_JWT можно расшифровать и посмотреть, [что в нем лежит](https://jwt.io). Если будут встречаться баги, обязательно проверь, что в токен отправляются `user_id` и `role`._

### Задание 6. Личная страница пользователя

Токен нужен сервису медцентра, чтобы убедиться, что сервис авторизации подтвердил данные входа пользователя и выдал токен, с которым теперь пользователь может быть определен в каждом сервисе. Например, в этом проекте сервис медцентра ожидает такую информацию (расшифрованный токен, который отправляется в сервис медцентра):

```json
{
  "token_type": "access",
  "exp": 1740836968,
  "iat": 1740836668,
  "jti": "d55f2b6fc3c2427b9af83898000a0975",
  "user_id": 7,
  "role": "doctor"
}
```

1. В файле `clinic/authentication.py` опиши логику авторизации пользователя при помощи `JWTAuthentication`.
    - Важно валидировать `user_id` и `role`.
2. В настройках REST_FRAMEWORK укажи кастомный аутентификатор.
3. Во `views.py` опиши простой Response, например:

    ```python
    @api_view(['GET'])
    @permission_classes([IsAuthenticated])
    def account_view(request):
        user = request.user # Объект DummyUser, полученный из токена.
        return Response({
            "message": "Добро пожаловать в личный кабинет!",
            "user_id": user.id,
            "role": user.role,
        })
    ```

4. Добавь в `urls.py` свежий эндпоинт `/account`.

### Бонусное задание 7. Закрытый доступ к странице

1. Добавь страницу `account/private`.
2. Ограничь доступ только для роли `doctor`.

Конечно, это всего лишь верхушка айсберга — тема безопасности в IT очень большая и сложная, а еще связана с большой ответственностью. Выполнив этот проект, ты узнал продвинутый способ работы с аутентификацией пользователей. Хотя в рамках этого проекта оба сервиса реализованы на Django, в настоящей разработке они могли быть разработаны на разных технологиях. Главное, чтобы сервис авторизации обеспечивал остальные сервисы токеном, который подтверждает юзера и его полномочия. 

---

С горем пополам ты все-таки сделал авторизацию и даже создал аккаунты. Тестируя работу приложения, ты смеха ради ввел ФИО Главврача в форму регистрации, но получил неожиданный результат:

>**Этот пользователь уже зарегистрирован**. 

>— ...
>>**Стажер**

Почему Главврач есть в БД клиники «Здоровый дух»? Да еще и в базе докторов. Ты покосился на камеру наблюдения, а затем на свой телефон, но сейчас никаких СМС, приходящих подозрительно вовремя, не было. Значит, сейчас он не следил за тобой? 

Однако не успел ты расслабиться, как тебе пришло вездесущее сообщение:

>Потрясающая работа! 
>>**Главврач**

СМС Главврача все больше напоминали ИИ-бота. А ты терялся в догадках, что этому человеку вообще от тебя нужно.

---

💡 [Нажми сюда](https://oprosso.ru/p/ad3bc98eb2a54c0baf4679fa722b54df), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твое обучение лучше.