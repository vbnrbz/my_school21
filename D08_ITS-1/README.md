# Функции

## Аннотация

Данный проект позволит тебе изучить, что такое функции и как с ними работать в Python.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Функции](#функции) \
    2.2. [Задание 1](#задание-1)
3. [Chapter III](#chapter-iii) \
    3.1. [Модули](#модули) \
    3.2. [Задание 2](#задание-2)
4. [Chapter IV](#chapter-iv) \
    4.1. [Аргументы функции](#аргументы-функции) \
    4.2. [Задание 3](#задание-3) \
    4.3. [Задание 4](#задание-4) \
    4.4. [Задание 5](#задание-5)
5. [Chapter V](#chapter-v) \
    5.1. [Задание 6](#задание-6)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер : 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

Начинается новый день, и ты заходишь в двери поликлинике. У регистратуры стоит главврач, и когда ты проходишь мимо, он замечает тебя.

> О, доброе утро, Ниф-Ниф!
> 
> Отличную работу вы проделали все вместе! Кстати, видел ваш код на GitLab. Выглядит неплохо, но уж слишком все громоздко.
> В следующий раз обязательно используйте функции и отдельные файлы для них.
>> **Главврач**

> Здравствуйте! Хорошо, я постараюсь.
>> **Стажер**

Да уж, тяжелые были эти два дня с Наф-Нафом и Нуф-Нуфом. Тьфу, какой Наф-Наф и Нуф-Нуф, главврач как-то странно на тебя влияет...
Но все-таки программу вы сделали клевую, думаешь ты. И судя по резко распахнутой двери и влетающей Елизавете Викторовне (старшей медсестре) 
с горящими глазами, не только ты так считаешь.

> Салют!
>> **Елизавета Викторовна (старшая медсестра)**

> ВерА!\
> Но я буду с тобой или буду один.\
> Дальше не сбежать, ближе не подойти.\
> Прежде чем навек поменять номера,\
> Салют, ВерА-А-А!
>> **Стажер (думает про себя)**

> Доброе утро.
>> **Стажер (произносит вслух)**

> Судя по твоему готовому принять все невзгоды взгляду, ты уже понял, что наш главврач мне все разболтал про вашу программу для терапевтов!
> То есть для терапевта вы программу для работы с расписанием из файла сделали, а мне, чтобы его сформировать, еще не сделали! Ну дела.
>
> Вы вообще знаете, что было первым: курица или яйцо? Нет?! Вот и я не знаю... Но в данном случае точно знаю, что расписание должно быть первым!
> И уж я не собираюсь вбивать его вручную!
>> **Елизавета Викторовна (старшая медсестра)**

> Но вас просто не было, а Антонина Павловна попросила нас ей помочь...
>> **Стажер**

> Да шучу я, не напрягайся ты так. Но факт остается фактом: формирование нормального расписания в файле сделать нужно.
> 
> Прошлое твое расписание неплохое, но мне его никак не передать врачам. Так что нужно сделать так, чтобы мы с ними имели доступ к одному файлу с расписанием.
>> **Елизавета Викторовна (старшая медсестра)**

> Согласен, сделаем.
>> **Стажер**

> Мне нужно отбежать на часок, ты пока морально подготовься.
>> **Елизавета Викторовна (старшая медсестра)**

## Chapter II

### Функции

Пока Елизавета Викторовна куда-то шла, ты вспоминаешь слова главврача о функциях. Самое время прочитать про них, чтобы использовать
новые знания в новых задачах. Ты начинаешь по старой доброй привычке искать похожие слова в архивах админа и находишь файл *function.txt*.

> Функция — это одна из основ любого языка программирования. Функция — это обособленный блок кода, который можно вызвать в любом другом месте
> сколько угодно раз. 
> 
> На самом деле, ты уже знаком с функциями. Когда ты пишешь слово `print`, ты вызываешь функцию,
> которая выводит строку на экран. Как она это делает? Да неважно, для тебя это черный ящик, тебе, главное, знать **аргументы**, которые надо 
> передать функции, и результат, который она возвращает. Ты знаешь, что первый и самый главный аргумент — это строка, которая выведется на экран.
> Но помимо этого, у `print` есть еще разные аргументы, например, `end`, который показывает, какое по умолчанию значение будет добавляться в конец твоей строки.
> Ты когда-нибудь задумывался, почему, если напишешь `print` два раза подряд, выводимое этими принтами будет на разных строках?
> Потому что по умолчанию `end='\n'`. А '\n' — это знак переноса строки. Если ты никогда не задавал этот аргумент, то попробуй. Сделай `end` равным пустой строке или другому символу.
> 
> Аргументы функции — это то, что принимает функция. Так же как и в математике — *f(x)*, где *f* — это функция, а *x* — аргумент функции.
> 
> В Питоне функция объявляется с помощью ключевого слова `def`.
> Функция может возвращать какой-то результат (с помощью ключевого слова `return`), а может ничего не возвращать. Функцию, которая ничего
> не возвращает, часто называют процедурой. Примеры объявления и вызова функций можно спокойно загуглить.
> 
> А зачем в целом нужны функции, если можно просто взять и скопировать код в то место, где он повторяется? 
> 
> Во-первых, это загромождение.
> Представь, что у тебя код считывает содержимое файла, обрабатывает его и отдает результат. Данный код занимает строк 30 и повторяется в общей кодовой базе не один раз.
> С каждым копированием кол-во общих строк кода будет возрастать, что затруднит его чтение. А поверь, даже если ты считаешь, что твой код, кроме тебя, никто не увидит,
> или тебе просто плевать на других разработчиков (пусть как хотят, так и разбираются, их проблемы), то гарантирую тебе: через неделю, а,
> может быть, даже пару дней, ты сам забудешь, что делает твой код, и тебе придется читать его заново. То есть увеличивая и усложняя кодовую базу, ты стреляешь себе будущему в ногу,
> ну и заодно всем тем, кто будет читать ее.
> 
> Во-вторых, существует так называемая **«Ошибка третьего копирования»**. Что это значит? Это значит, что если ты копируешь что-то несколько раз, то
> на третий раз ты точно ошибешься. Как так, спросишь ты. Ведь ты просто делаешь Ctrl+C, Ctrl+V. На самом деле, в коде часто бывает такое, когда
> условно 95% копируемого кода остается тем же, но 5% нужно изменить. Например, возьмем все то же чтение файла. Все один в один, но меняется
> только путь к файлу. Вот тут и вступает «Ошибка третьего копирования». На какой-то раз ты точно забудешь изменить путь к файлу на новый, и программа будет работать неверно.
> Вот для этого и нужны функции. Вместо копирования 30 строк кода и смены пути в нужном месте тебе нужно будет лишь вызвать функцию, передав в качестве аргумента новый путь.
> И да, если ты думаешь, что ну уж ты-то точно внимательный и не допустишь такой ошибки, то могу лишь улыбнуться в ответ.
> 
> В-третьих, представь, что ты пишешь этот код с чтением и обработкой. Уже скопировал его раза 3 в другие части кода, сумел избежать «Ошибки третьего копирования», все работает правильно.
> И тут тебя осеняет, что ты допустил логическую ошибку в обработке. Или же вообще заказчик сказал тебе как-то переделать обработку.
> И что ты будешь делать в данном случае? Правильно, ты пойдешь править код в 3(!) разных местах. В случае функции ты бы сходил в 1(!) место и поправил бы код только там.
> Ну и, естественно, изменяя код в 3 местах, ты увеличиваешь шанс ошибиться в одном из этих мест.

### Задание 1

Твое увлекательное чтение прерывает вошедшая старшая медсестра.

> Я наконец освободилась, давай приступим. Я глянула тот формат расписания в csv-файле, который вы подготовили для терапевтов.
> Меня он устраивает. То есть наша задача для начала — накидать программу, которая будет формировать шаблон расписания с метками времени
> для записи.
> 
> Начнем немного издалека. Давай сначала сформируем список времен для записи. Я не хочу вбивать все времена.
> Давай поступим так: мы знаем рабочее время врача, т. е. фактически время первого и последнего приема. На каждый прием обычно отводится одинаковое
> количество минут. Вот хочу, чтобы, когда я задаю время первого приема, время последнего и продолжительность одного приема, программа мне возвращала список
> времен для записи.
>> **Елизавета Викторовна (старшая медсестра)**

**Для этого и последующих заданий необходимо помнить, что в качестве рабочей папки (working directory) в PyCharm необходимо задавать
папку с проектом. Тогда все относительные пути к файлам и относительные импорты будут работать корректно.**

Время попробовать на практике реализовать код через функции. Если попробовать применить функции, то получается:
1. Врач вводит в клавиатуры:
   - время первого приема — `08:00`;
   - время последнего приема — `13:30`;
   - продолжительность одного приема в минутах — `30`.
2. При вводе с клавиатуры врач должен видеть следующие надписи в разных инпутах (порядок инпутов обязателен):
   - `Enter the time of first appointment (08:00): `;
   - `Enter the time of last appointment (13:30): `;
   - `Enter the duration of one appointment in minutes (15): `.
3. Текст, который видит врач при вводе, должен быть выведен на экран только с помощью `input`, а не через `print`!
4. Зная эти параметры, необходимо сформировать список времен (список строк).
Пример: `['08:00', '08:30', '09:00', '09:30', '10:00', '10:30', '11:00', '11:30', '12:00', '12:30', '13:00', '13:30']`.
5. Код для формирования данного списка необходимо записать в функции `get_list_timestamps_for_schedule`. Функция должна принимать на вход 3 аргумента `start`, `end` и `step`, которые соотносятся с 3 введенными с клавиатуры значениями. 
Тип всех аргументов должен быть строковым!
6. Функция должна возвращать список строк (не выводить их на экран, а просто возвращать!).
7. Ввод с клавиатуры и вывод на экран осуществить вне функции, т. е.:
```
<Объявление функции>

<Ввод с клавиатуры>

<Вызов функции>

<Вывод на экран результата, который вернула функция>
```

P.S. Как один из вариантов, можно попробовать использовать библиотеку `datetime`.

## Chapter III

### Модули

Ты доделал 1 задание и в ожидании Елизаветы Викторовны продолжаешь читать инструкции админа.

> Я уже сказал, что функции помогают сделать код менее громоздким. Но что, если код все равно большой и функций в нем много?
> Получится огромный файл. Чтобы еще более оптимизировать кодовую базу, можно разнести этот код по разным файлам.
> Эти файлы с кодом называются модулями. Набор модулей — уже библиотека. Как ты думаешь, что происходит, когда ты пишешь `import datetime`?
> Ты считываешь все содержимое файла с названием `datetime`, который где-то лежит. Ты даже можешь перейти в этот файл: надо выделить в импорте
> слово `datetime` и нажать Ctrl+B (в PyCharm при английской раскладке клавиатуры!). После этого ты окажешься в этом файле, в
> котором реализована куча функций.
> 
> Когда же ты пишешь `from datetime import datetime`, это означает, что ты из файла `datetime` вызываешь сущность `datetime`. 
> В данном случае это класс (что это такое, см. в других записях), но может быть и переменная, и функция.
> 
> Все это подводит к тому, что ты можешь написать какой-то код в отдельном файле, а в другом тем же механизмом импортировать из него
> то, что тебе нужно. Например, ты можешь в отдельном файле реализовать функции, которые будешь вызывать в другом файле.
> 
> Важный момент, что если файл с кодом находится в какой-то папке, то нужно прописывать путь до этого файла. 
> Допустим, есть папка с проектом (не забывай ее всегда делать рабочей в PyCharm, иначе все пути (включая пути в импортах) будут
> считываться неправильно). В ней есть папка *code/* с двумя файлами *utils.py* и *main.py*.
> ```
> project_directory
> |
> |-code
>   |
>   |-utils.py
>   |-main.py
> ```
> В файле *utils.py* реализована функция `func`, которую надо импортировать в файл *main.py*.
> Тогда в файле *main.py* мы осуществляем импорт относительно рабочей папки (это не единственный, но РЕКОМЕНДУЕМЫЙ способ) через точку:
> ```
> from code.utils import func
> ```
> 
> Кстати, есть еще одна интересная конструкция, которую обычно постоянно используют:
> ```python
> if __name__ == "__main__":
>   ...
> ```
> 
> Код внутри этого блока `if` выполняется только в том случае, если запускается данный конкретный файл, где записана эта конструкция.
> Можно построить следующую логику, когда файл запускается напрямую, то он обозначается как главный (`__main__`).
> Тогда этот блок проверяет, является ли этот файл точкой входа (запуска) во всю кодовую базу.
> 
> Обычно главный файл оформляют следующим образом:
> ```python
> <необходимые импорты>
> 
> def main():
>   ...
> 
> 
> if __name__ == "__main__":
>   main()
> ```
> То есть вся основная логика прописана в функции `main`, которая вызывается в нижнем блоке. 
> Весь вызов вспомогательных функций осуществляется внутри функции `main`.

### Задание 2

Пока старшая медсестра еще не пришла, ты решаешь поправить свой код согласно новым полученным знаниям:
1. Функцию `get_list_timestamps_for_schedule` необходимо скопировать в файл *src/utils.py*.
2. В файле *src/task_2.py* необходимо импортировать данную функцию относительно папки репозитория.
3. В файле *src/task_2.py* необходимо реализовать функцию `main`, в которой прописать ввод с клавиатуры, вызов функции и вывод на экран результата функции (то есть всю основную логику).
4. Вызов функции `main` осуществить в блоке `if __name__ == "__main__":`.

P.S. Перед запуском всегда необходимо проверять, что правильно задана рабочая папка проекта (папка репозитория), иначе пути при
импорте могут считываться неправильно.

## Chapter IV

### Аргументы функции

Куда же делась Елизавета Викторовна? В целом, тебе есть чем заняться: ты продолжаешь читать о функциях.

> Совсем немного подробнее расскажу об аргументах.
> 
> Аргументы позволяют задавать значения по умолчанию, что делает аргумент необязательным для передачи. 
> То есть если аргумент не был передан, то в качестве его значения будет взято значение по умолчанию.
> 
> Кстати о передаче аргументов в функции при их вызове. Аргументы при вызове функции делятся на позиционные и именованные.
> В чем отличие, можешь почитать в интернете. Главное— понимать, что аргументы в функцию можно передать как в виде позиционных, 
> так и в виде именованных. Я даже больше скажу: одни можно в виде позиционных, а другие в виде именованных, все на выбор разработчика.
> Запомни, что при передаче аргументов обязателен следующий порядок: сначала передаются позиционные, а уже потом именные.
> При этом порядок позиционных аргументов при передаче в функцию должен точно совпадать с порядком аргументов при задании функции. 
> 
> Есть еще одна важная особенность, связанная с аргументами. Это установка функции возможности передавать любое динамическое 
> количество позиционных и именованных аргументов. В документации такие аргументы часто выглядят, как `*args` и `**kwargs`.
> Например, есть функция, у которой есть такой аргумент `*args`:
> ```python
> def func(*args):
>   ...
> ```
> Это значит, что при вызове функции `func` в нее можно передать абсолютно любое кол-во позиционных аргументов, которые будут записаны в переменную `args`,
> которая, в свою очередь, будет просто кортежем, т. е. при выполнении этого кода:
> ```python
> def func(*args):
>   print(args)
> 
> func(1, 2, 3, 4, 5)
> ```
> на экран выведется `(1, 2, 3, 4, 5)`.
> 
> Для `**kwargs` все аналогично, просто тогда в функцию можно будет записать любое кол-во именованных аргументов, которые будут записаны
> в переменную `kwargs`, которая будет являться словарем.
> 
> Ну и последнее, при вызове функции есть похожий тип записи — `func(*some_list)`, где `some_list` — какая-то коллекция, типа кортежа или списка.
> Или же `func(**some_dict)`, где `some_dict` — какой-то словарь. Это так называемая распаковка элементов из списков/словарей в аргументы
> функции. Как это работает, ознакомься сам, а то мне уже пора бежать. 

### Задание 3

В комнату наконец входит старшая медсестра.

> Извини, сегодня в регистратуре какой-то аншлаг, ни минутки свободной. Я так понимаю, что ты все сделал?
> Отлично, тогда давай в качестве следующего задания сформируй мне уже конкретно расписание в том виде, которое
> ты делал для Антонины. То есть 3 столбца: «Time», «Patient», «The patient visited the doctor» в csv-файле, разделенные запятой.
> Первый столбец заполни из списка, который у тебя уже получается, второй оставь пустым, а третий весь заполни словом «No».
> 
> Хотя... это слово «No» было у Антонины. Честно говоря, оно мне пока не нравится. Давай так, сделай, чтобы программа спрашивала
> у меня, какое слово или символ я хочу записать в этот столбец. Если же я ничего не введу, то пусть по умолчанию будет «No».
> Хочу поэкспериментировать с красотой.
> 
> Расписание само запиши в файл *src/schedule.csv*. Это будет шаблоном, куда я потом буду записывать пациентов.
>> **Елизавета Викторовна (старшая медсестра)**

Звучит понятно, нужно продолжать использовать новые знания, поэтому ты представляешь задачу в следующем виде:
1. Врач вводит в клавиатуры:
   - время первого приема — `08:00`;
   - время последнего приема — `13:30`;
   - продолжительность одного приема в минутах — `30`;
   - строку, которая будет записана во все строки в 3 столбец расписания — `Not yet`;
2. При вводе с клавиатуры врач должен видеть следующие надписи в разных инпутах (порядок инпутов обязателен):
   - `Enter the time of first appointment (08:00): `;
   - `Enter the time of last appointment (13:30): `;
   - `Enter the duration of one appointment in minutes (15): `;
   - `Enter the text that will be displayed in the column "The patient visited the doctor" by default (if you just press Enter, the default will be "No"): `.
3. Текст, который видит врач при вводе, должен быть выведен на экран только с помощью `input`, а не через `print`!
4. Реализовать функцию `create_schedule` в файле *src/utils.py*, которая принимает 2 аргумента — `timestamps` и `default_value`.
Аргумент `timestamps` принимает список меток времени в виде строк (`['08:00', '08:30', '09:00']`). Аргумент `default_value` отвечает за значение во всех строках в 3 столбце и имеет строковый тип данных.
Аргумент также имеет значение по умолчанию — «No»!
5. Функция должна формировать расписание и записывать его в файл *src/schedule.csv*. Путь до файла указывать относительный (относительно папки с проектом).
Вид файла после записи (со значением по умолчанию «No»):
    ```
    Time,Patient,The patient visited the doctor
    08:30,,No
    09:00,,No
    08:00,,No
    09:30,,No
    ```
    Помимо записи в файл, функция должна возвращать расписание в виде списка списков:
    ```
    [['Time', 'Patient', 'The patient visited the doctor'], ['08:00', '', 'No'], ['08:30', '', 'No'], ['09:00', '', 'No'], ['09:30', '', 'No']]
    ```
6. С помощью библиотеки `tabulate` вывести сформированное расписание на экран в формате `github`, т. е.:
    ```
    | Time   | Patient   | The patient visited the doctor   |
    |--------|-----------|----------------------------------|
    | 08:00  |           | No                               |
    | 08:30  |           | No                               |
    | 09:00  |           | No                               |
    | 09:30  |           | No                               |
    ```
7. В файле *src/task_3.py* необходимо реализовать функцию `main`, в которой прописать ввод с клавиатуры, вызов вспомогательных функций
`get_list_timestamps_for_schedule` и `create_schedule` и вывод на экран расписания.
8. Вызов функции `main` осуществить в блоке `if __name__ == "__main__":`.

Не обязательно, но можно отдельно сделать функцию для записи данных в csv файл `write_to_csv` в файле *src/utils.py*, которая уже будет вызываться внутри функции `create_schedule`.

### Задание 4

> Так, выглядит отлично. С помощью этой программы я буду формировать шаблон расписания для заполнения. Теперь нужно реализовать возможность 
> вписывать туда самих пациентов в нужное время. Чтобы потом уже этот же файл считывали терапевты.
> 
> Тут все просто: хочу, чтобы была возможность вписать время и ФИО самого пациента с клавиатуры. И в файл *schedule.csv* под нужное
> время вписывалось бы это ФИО. Хочу это делать до тех пор, пока не нажму определенную кнопку.
>> **Елизавета Викторовна (старшая медсестра)**

Получается, тебе нужно:
1. При запуске программы пользователь должен видеть считанное с файла *src/schedule.csv* расписание через `tabulate` в формате `github`, выведенное через принт.
При этом при чтении файла путь до него должен быть относительным (относительно папки с проектом). 
После расписания он должен видеть приглашение к вводу одной из двух опций (кол-во черточек должно быть равно 60,
а приглашение к вводу от черточек до черточек включительно должно быть выведено через `input`, а не через `print`):
    ```
    | Time   | Patient   | The patient visited the doctor   |
    |--------|-----------|----------------------------------|
    | 08:00  |           | -                                |
    | 08:30  |           | -                                |
    | 09:00  |           | -                                |
    | 09:30  |           | -                                |
    | 10:00  |           | -                                |
    | 10:30  |           | -                                |
    ------------------------------------------------------------
    Enter:
     - 1, if you want to add a patient to the schedule;
     - 2, if you want to finish forming the schedule.
    ------------------------------------------------------------
    ```
2. Программа должна работать, пока пользователь не выбрал опцию 2.
3. При выборе опции 1 пользователь по очереди должен ввести время и ФИО:
    - `Enter the time you want to schedule the patient, it must be in the schedule (08:00): `;
    - `Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): `.
4. После ввода ФИО нужно привести его к формату `Ivanov Ivan Ivanovich`, где первые буквы заглавные, а остальные строчные.
5. Реализовать функцию `add_patient_to_schedule` в файле *src/utils.py*, которая принимает 2 аргумента — `time` и `patient`.
Функция должна принимать время и ФИО пациента (уже приведенное в нужный вид), проверять, есть ли такое время в расписании из файла, 
    - если есть, то записывать напротив этого времени во 2 колонку ФИО пациента, сохранять изменения в файл *src/schedule.csv* и 
возвращать обновленное расписание в виде списка списков (см. задание 3, пункт 5).
    - если нет, то выводить на экран `This time is not on the schedule!`, возвращать текущее расписание без изменений в виде списка списков (см. задание 3, пункт 5).
6. Далее нужно показывать пользователю обновленное расписание (через `print`) и предлагать снова выбрать опцию (через `input`):
    ```
    | Time   | Patient               | The patient visited the doctor   |
    |--------|-----------------------|----------------------------------|
    | 08:00  | Ivanov Ivan Ivanovich | -                                |
    | 08:30  |                       | -                                |
    | 09:00  |                       | -                                |
    | 09:30  |                       | -                                |
    | 10:00  |                       | -                                |
    | 10:30  |                       | -                                |
    ------------------------------------------------------------
    Enter:
     - 1, if you want to add a patient to the schedule;
     - 2, if you want to finish forming the schedule.
    ------------------------------------------------------------
    ```
7. В файле *src/task_4.py* необходимо реализовать функцию *main.py*, в которой прописать всю основную логику, кроме той, которая
должна быть в функции `add_patient_to_schedule`.
8. Вызов функции *main* осуществить в блоке `if __name__ == "__main__":`.

Не обязательно, но можно отдельно сделать функцию для чтения данных из csv файла *read_csv* в файле *src/utils.py*, которая уже будет вызываться внутри функции *add_patient_to_schedule*.

P.S. Если внутри функции осуществляется бесконечный цикл, и выход из цикла равен выходу из функции, то вместо **break** можно использовать пустой **return**. Функция завершится вместе с циклом и ничего не вернет.

### Задание 5

> Уже сделал? Молодец! Я, как всегда, пока отходила, вспомнила кое-что еще. Иногда нам нужно занимать какое-то время техническими
> вещами — убраться, продезинфекционировать помещения или даже банально поставить врачу обед. Эти технические времена динамичные, 
> то есть изо дня в день они могут меняться. Дай мне, пожалуйста, возможность задавать эти времена через запятую. В расписание напротив
> данных времен нужно будет ставить «Technical time».
> 
> Я думаю, что на сегодня это последнее, что я хочу.
>> **Елизавета Викторовна (старшая медсестра)**

Осталось немного, а именно:
1. Добавить одну опцию для ввода технических времен:
    ```
    | Time   | Patient   | The patient visited the doctor   |
    |--------|-----------|----------------------------------|
    | 08:00  |           | No                               |
    | 08:30  |           | No                               |
    | 09:00  |           | No                               |
    | 09:30  |           | No                               |
    ------------------------------------------------------------
    Enter:
     - 1, if you want to add a patient to the schedule;
     - 2, if you want to add technical time;
     - 3, if you want to finish forming the schedule.
    ------------------------------------------------------------
    ```
2. При выборе опции 2 пользователь по очереди должен ввести список технических времен через запятую с пробелом.
При этом он должен видеть следующее приглашение к вводу (реализованное через `input`!):
   ```
   Enter technical times separated by commas and spaces, they should be in the schedule (08:00, 09:30): 
   ```
3. Введенную строку необходимо будет преобразовать в список временных меток.
4. Реализовать функцию `add_tech_times_to_schedule` в файле *src/utils.py*, которая принимает аргумент со списком временных меток `times`.
При этом реализовать объявление этой функции и передачу в нее аргументов через `*times` (нужно же хоть потрогать, что это). То есть через динамическую передачу позиционных аргументов.
Функция `add_tech_times_to_schedule` должна принимать список временных меток, искать их в расписании (считанном из файла) и, если такие метки найдены, ставить напротив этих времен во 2 колонке `Technical time`. 
Если не найдены, то не делать ничего. Функция должна сохранять изменения в файл *src/schedule.csv* и возвращать обновленное расписание в виде списка списков (см. задание 3, пункт 5).
5. Остальной функционал оставить, как в Задании 4.
6. Пример того, что будет видеть пользователь после введенных технических времен:
    ```
    Enter technical times separated by commas and spaces, they should be in the schedule (08:00, 09:30): 08:00, 09:30
    | Time   | Patient        | The patient visited the doctor   |
    |--------|----------------|----------------------------------|
    | 08:00  | Technical time | No                               |
    | 08:30  |                | No                               |
    | 09:00  |                | No                               |
    | 09:30  | Technical time | No                               |
    ------------------------------------------------------------
    Enter:
     - 1, if you want to add a patient to the schedule;
     - 2, if you want to add technical time;
     - 3, if you want to finish forming the schedule.
    ------------------------------------------------------------
    ```

> Пример работы программы можно посмотреть в файле *materials/example_of_work.txt*. Данный пример основан на чистом расписании,
> которое можно сформировать с помощью задания 3.
>> **Голос свыше**

## Chapter V

### Задание 6

> Какой же ты все-таки молодец. Спасибо тебе большое! Не забудь залить свои наработки на сервер.
>> **Елизавета Викторовна (старшая медсестра)**

Последним штрихом необходимо запушить свои наработки на GitLab в ветку `develop`, включая *src/utils.py*, со всеми разработанными за проект функциями.
Файл *src/schedule.csv* пушить не нужно!

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
