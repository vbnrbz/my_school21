# Стандарты написания кода и линтеры

## Аннотация

Данный проект позволит тебе подробнее изучить, как писать красивый код, что такое PEP, линтеры, форматировщики кода, и как ими пользоваться.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [PEP и стандарты оформления кода](#pep-и-стандарты-оформления-кода) \
    2.2. [Задание 1](#задание-1) \
    2.3. [Задание 2](#задание-2) \
    2.4. [Задание 3](#задание-3)
3. [Chapter III](#chapter-iii) \
    3.1. [Линтеры](#линтеры) \
    3.2. [Задание 4](#задание-4) \
    3.3. [Задание 5](#задание-5)
4. [Chapter IV](#chapter-iv) \
    4.1. [Форматировщики кода](#форматировщики-кода) \
    4.2. [Задание 6](#задание-6)
5. [Chapter V](#chapter-v) \
    5.1. [Задание 7](#задание-7)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер: 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

И вот наступает твой последний день в качестве стажера этой поликлиники. Это было необычное время, ты узнал много нового, но почти ничего по своей основной специальности. Однако у тебя странное чувство, что лишних знаний не бывает. Никогда не знаешь, что может пригодиться в жизни.

В кабинет входит главврач, который выглядит на удивление серьезным.

> Доброе утро, Стажер! Хороший сегодня день, хоть и грустный. Почему грустный? Грустно, что сегодня твоей последний день.
> И жаль, что ты еще учишься, мне бы пригодился в штате такой работник, как ты.
> 
> Как видишь, сегодня даже нет настроения шутить. Поэтому давай проведем этот день с пользой, хочу напоследок дать тебе
> еще немного знаний. Ну что, готов к финишной прямой?
>> **Главврач**

> Всегда готов!
>> **Стажер**

## Chapter II

### PEP и стандарты оформления кода

> До сегодняшнего дня тебя практически ничего не ограничивало в том, как писать код. Только правила самого языка,
> такие как отступы, двоеточия в нужных местах, ключевые слова и т. д. Но это именно сам язык, без соблюдения этих правил
> код бы не запустился. Однако тебя никто не ограничивал в том, как, например, присваивать переменную в рамках дозволенного:
> ```python
> a=1
> ```
> так:
> ```python
> a = 1
> ```
> или так:
> ```python
> a =1
> ```
> Все эти куски кода выполнились бы интерпретатором Python без вопроса. Но ты мог заметить, что иногда PyCharm может подчеркивать
> тебе какой-то код, который вроде как и так выполняется. Почему? Потому что, по мнению PyCharm, писать так код — некрасиво.
> 
> И тут возникает вопрос. А что, есть какое-то понимание, какой код красивый, а какой нет?
> 
> Python, как ты уже понял, не имеет очень строгих правил, которые контролируют все и вся, это очень гибкий язык. Однако
> тут есть нюанс. Это как с мнениями. Сколько людей, столько и мнений. Так же и с разработчиками — сколько разработчиков, 
> столько и стилей кода, которых они придерживаются. У кого-то есть правило: все функции начинаются с большой буквы, у кого-то: 
> все функции начинаются только с маленькой. 
> 
> Во время групповых работ ты, возможно, немного ощутил, что, глядя на чужой код, тебе бывает сложно его понять. А теперь представь,
> что разработчик с одним стилем кода проверяет код разработчика с другим вкусом. О-о-о, это будет очень неприятно.
> Поэтому разработчики Python как комьюнити начинают придумывать какие-то свои стандарты разработки, которые они популяризируют
> и затем придерживаются.
> 
> И вот тут на сцену выходит **PEP** — **Python Enhancement Proposal**. Это набор документов, которые описывают:
> 1. Новые возможности и процессы в языке.
> 
>    Например, когда вышла версия Python 3.6, в нее были добавлены аннотации и к ним сразу
> был выпущен [**PEP 484**](https://peps.python.org/pep-0484/) — документ, который описывает, как создатели аннотаций
> советуют ими пользоваться.
> 2. Документирование процессов, связанных с разработкой.
> 
>    Например, есть документы, которые вводят стандарты оформления кода, правила ведения документации или тестирования.
> 
> Нужно понимать, что все документы PEP — это лишь попытка сообщества предложить общие стандарты, чтобы найдя код в интернете
> от какого-нибудь индуса, ты мог его так же легко понять, как будто это писал твой однокурсник. Они не являются обязательными.
> Однако некоторые из этих документов так прочно вошли в общий обиход, что если ты не будешь их придерживаться, то тебя 
> просто не поймут, а, возможно, даже осудят. А если ты еще и будешь джуном в компании — заставят переписывать все согласно
> стандартам.
> 
> Самый популярный PEP — это [**PEP 8**](https://peps.python.org/pep-0008/), который описывает общий стиль кода. Это,
> как говорится, БАЗА. Ты можешь не знать никаких других пепов, но PEP 8 ты знать обязан. И не только знать, но и придерживаться. 
> Этот документ был составлен создателем Python, и огромное количество разработчиков на него опираются.
> 
> А теперь давай перейдем к практике.
>> **Главврач**

### Задание 1

> Давай начнем с базы, то есть с PEP 8.
> 
> Я подготовил тебе файл *src/task_1.py*, в котором лежит код. Твоя задача — поправить его согласно
> [**PEP 8**](https://peps.python.org/pep-0008/).
> 
> Замечу, что часто PyCharm сам обращает внимание на те участки кода, которые не соответствуют этому стандарту, но не всегда.
> Поэтому все равно прочитай оригинальный документ. Этот документ можно также найти на русском языке в интернете.
>> **Главврач**

Тут все предельно понятно. Файл *src/task_1.py* ждет тебя.

### Задание 2

> Давай закрепим PEP 8 на файле *src/task_2.py*. Задание такое же — поправить код согласно документу
> PEP 8.
> 
> Единственное замечание: библиотека `tabulate` является не встроенной (т. е. не из стандартной библиотеки), а внешней. Обрати на это внимание при форматировании
> файла.
>> **Главврач**

### Задание 3

> Ну и для разнообразия давай рассмотрим еще два документа PEP:
> 1. [**PEP 484**](https://peps.python.org/pep-0484/) — ранее упоминавшийся мной, который рассказывает о стандартах проставления аннотаций.
> 2. [**PEP 257**](https://peps.python.org/pep-0257/) — который описывает стандарт написания **докстрингов**. Если не знаешь, что
> это, то самое время изучить.
> 
> Я подготовил файл *src/task_3.py*, в который тебе необходимо скопировать отредактированный по PEP 8
> класс `ScheduleHospital` из второго задания и:
> 1. Проставить в данном классе везде докстринги (для класса и **всех** методов этого класса) согласно PEP 257.
> Докстринги должны быть следующие:
>   - для самого класса — однострочный докстринг `Class for working with schedules of doctors`;
>   - для метода `__init__` — однострочный докстринг `A magic method that is called when an object is initialized.`;
>   - для метода `print_schedule` — многострочный докстринг, где в качестве первой строки должна быть строчка: `Function for beautiful display of the schedule on the screen`,
>   а на остальных строчках — дополнительные пояснения к этой функции (на твой выбор);
>   - для метода `write_to_csv` — многострочный докстринг, где в качестве первой строки должна быть строчка: `Function for writing a schedule to a file`,
>   а на остальных строчках — дополнительные пояснения к этой функции или описания аргументов (на твой выбор).
> 2. Проставить согласно PEP 484 аннотации во всех методах класса.
> 3. В блоке `if __name__ == "__main__":` напиши код для вывода на экран всех докстрингов, обративших к ним через объект класса `sch`.
>> **Главврач**

Приятно, когда все за тебя разжевывают, главное, не забыть о файле *src/task_3.py*.

## Chapter III

### Линтеры

> Вот скажи мне, когда ты читал все эти документы и правил по ним код, тебе не приходила в голову ворчливая мысль: «Какого черта
> это еще не проверяется автоматически везде?» И тут я тебе отвечу: многие из этих правил действительно можно проверить.
> Помимо встроенных в среды разработки внутренних штук для проверки кода (по типу подчеркиваний в PyCharm), существуют еще
> и специальные программы — **линтеры**.
> 
> Линтеры — это программы для анализа кода, которые могут проверять:
> 1. Синтаксис, как, например, пропущенные кавычки, неправильно использованные операторы и т. д.
> 2. Стиль, например, по PEP 8.
> 3. Качество кода. Есть общепризнанные правила написания определенных кусков кода, которые можно проверять линтерами.
> 
> Существует большое количество линтеров, но мы с тобой рассмотрим только два — это **ruff** и **mypy**.
> 
> **Ruff** — это огромный линтер, который может проверять все три вышеперечисленные пункта. Это действительно очень большой
> и гибкий в настройке линтер. Внутри него существует множество правил, которые можно включить или отключить
> при проверке твоего кода. Каким правилом следовать, а каким нет, решает сама команда разработки или технические, или архитектурные
> комитеты больших компаний.
> 
> **MyPy** — это линтер, который используется для проверки корректности аннотаций и передаваемых типов в коде. Это довольно
> важный линтер, так как Python является языком программирования с динамической типизацией, которая не фиксирует типы у 
> переменных.
> 
> Для настройки линтеров обычно используются специальные конфигурационные файлы. Например, для ruff можно использовать
> конфигурационный файл *.ruff.toml*. А для mypy — файл *mypy.ini*.
> 
> Думаю, ты уже должен был догадаться, что теперь необходимо проверить, как они работают на практике. Они уже
> установлены на твой компьютер, однако создать конфигурационные файлы для них ты должен будешь сам.
>> **Главврач**

### Задание 4

> Начнем, пожалуй, с ruff.
> 
> Файл *src/task_4.py* содержит код, в котором присутствуют несоответствия правилам линтера ruff.
> Я хочу, чтобы ты в папке репозитория создал файл *.ruff.toml*, в котором прописал бы следующие настройки:
> 1. Максимальная длина строки, которая допускается в коде — 120.
> 2. Для проверок нужно включить все правила в ruff, кроме следующих: T201, RUF001, COM812, INP001, PLR0912, C901,
> D100, D203, D211, D212, D213, D401. Обязательно прочитай, что это за правила.
> 
> Далее запусти ruff через терминал на файле *src/task_4.py*. Посмотри все выпадающие ошибки, прочти, что
> они значат, как их следует исправить согласно рекомендациям ruff, и исправь их.
> 
> Делай это до тех пор, пока ruff, запущенный над этим файлом, не выдаст следующую строчку: `All checks passed!`.
>> **Главврач**

Самое главное, что править код нужно прямо в файле *src/task_4.py*.

### Задание 5

> А теперь давай проделаем такое же упражнение для mypy.
> 
> Файл *src/task_5.py* содержит непроставленные аннотации, а также неправильно передаваемые типы
> в качестве параметров при вызове. Каждый метод или функция содержит в себе докстринг, из которого можно понять, что должна
> принимать функция и что возвращать (**в первую очередь ориентируйся на них!**). Внутри функции `main` содержатся вызовы функций, в которые
> передаются аргументы неправильных типов. Например, функция складывает два целых числа, а при ее вызове передаются два списка.
> Это специально допущенные ошибки, которые в дальнейшем нужно будет исправить.
> 
> Я хочу, чтобы ты в папке репозитория создал файл *mypy.ini*, в котором включил бы строгий тип проверки mypy — `strict`.
> Разберись, как это делается. Эта настройка включает довольно строгие проверки типизации.
> 
> Далее запусти mypy через терминал на файле *src/task_5.py*. Посмотри все выпадающие ошибки, прочти, что
> они значат, узнай, как их следует исправить согласно рекомендациям mypy, и исправь их. Не забудь также поправить вызовы функций,
> заменив аргументы неправильных типов на правильные. Значения же аргументов могут быть любые. Например, функция принимает два целых числа,
> допущена ошибка, и при ее вызове передаются два списка. Тебе нужно подставить в вызов функции любые два целых числа.
> 
> Тебе нужно добиться того, чтобы mypy выдавал следующую строчку: `Success: no issues found in 1 source file`.
>> **Главврач**

Почти все то же самое, только другой линтер и другой файл — *src/task_5.py*.

## Chapter IV

### Форматировщики кода

> И последнее по порядку, но не по значению, что стоит упомянуть — это форматировщики кода. Это что-то типа линтеров, но
> которые не просто указывают на то, что нужно поправить, а сами форматируют код в зависимости от внутренних или внешних настроек.
> 
> Одним из самых популярных форматеров кода является **black**. Он форматирует код в соответствии со множеством правил и
> позволяет сделать код от разных разработчиков единообразным. Black очень сильно ограничивает количество настроек, которые
> доступны извне. Это позволяет избежать долгих дискуссий о том, каких правил стоит придерживаться, а каких нет. Вы фактически
> просто принимаете тот факт, что теперь код всей вашей команды выглядит в одном стиле — стиле, заложенном в black.
> 
> Плюс black также заключается в его быстродействии. Он может быстро отформатировать код даже на больших проектах.
>> **Главврач**

### Задание 6

> А теперь пришло время потренироваться.
> 
> Выбери абсолютно любой код из своих предыдущих проектов. Желательно из последних заданий, когда его было побольше. Скопируй его
> в файл *src/task_6.py*. А после этого запусти на нем black. 
> 
> Тебе необходимо сделать так, чтобы последующие запуски black на том же файле выдавали в конце строку: `1 file left unchanged.`.
> 
> Посмотри на то, как black отформатировал твой код. Можешь потренироваться и на других кусках своего кода.
>> **Главврач**

## Chapter V

### Задание 7

> Честно говоря, я не люблю долгие прощания. И настроения шутить тоже нет. Поэтому скажу лишь одно: ты можешь гордиться собой. 
> Это был действительно тяжелый интенсив, который требовал не только мозгов, но и силы воли. И, как по мне, ты
> отлично со всем справился, раз слышишь от меня сейчас эти слова.
> 
> Я очень надеюсь, что ты не забросишь знакомство с языком программирования Python и в целом с IT-областью. 
> 
> Ну и напоследок скажу одно: не забудь запушить сегодняшние задания. :)
>> **Главврач**

Эх, даже не верится, что это последний твой пуш (в ветку `develop`, само собой) проекта на этой стажировке. 
И да, нужно не забыть помимо файлов *src/task_№.py* запушить еще файлы *.ruff.toml* и *mypy.ini* (из корня проекта)!

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
