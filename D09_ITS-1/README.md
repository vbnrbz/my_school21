# ООП

## Аннотация

Данный проект позволит тебе изучить основы объектно-ориентированного программирования в Python.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Принципы ООП](#принципы-ооп) \
    2.2. [Задание 1](#задание-1)
3. [Chapter III](#chapter-iii) \
    3.1. [Метод init](#метод-init) \
    3.2. [Задание 2](#задание-2)
4. [Chapter IV](#chapter-iv) \
    4.1. [Методы объекта](#методы-объекта) \
    4.2. [Задание 3](#задание-3) 
5. [Chapter V](#chapter-v) \
    5.1. [Приватные методы](#приватные-методы) \
    5.2. [Задание 4](#задание-4) 
6. [Chapter VI](#chapter-vi) \
    6.1. [Постановка задачи](#постановка-задачи)
    6.2. [Задание 5](#задание-5) \
    6.3. [Задание 6](#задание-6)
7. [Chapter VII](#chapter-vii) \
    7.1. [Задание 7](#задание-7)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер : 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

Ты заходишь в поликлинику и видишь главврача у стойки регистратуры. Возникает резкое чувство дежавю...

> Привет!
> 
> Видел твой код на GitLab. Приятно видеть, что мои слова про функции так быстро трансформировались в реальный код и твои новые знания.
> А что, если нам попробовать продолжить?
> 
> Ты слышал что-нибудь об ООП?
>> **Главврач**

> Здравствуйте!
> 
> Это общество охраны природы?
>> **Стажер**

> Я, конечно, люблю природу, но давай без охраны обойдемся. Я про объектно-ориентированное программирование.
> Попробуй следующие пару задач решить с его помощью. Судя по твоим успехам, это вполне может быть тебе по плечу.
>> **Главврач**

> Хорошо, я постараюсь. Прошу прощения, а откуда вы все это знаете?
>> **Стажер**

> Да так, там что-то услышал, тут где-то прочитал. Нужно ведь обладать широким кругозором, не так ли? Ну бывай, мне пора по делам.
>> **Главврач**

Главврач уходит в направлении своего кабинета, а из регистратуры на тебя выжидающе смотрит старшая медсестра.

> Здравствуйте, Елизавета Викторовна! Извините, я вас не заметил.
>> **Стажер**

> Доброе утро! Ну да, а «слона я в комнате и не заметил». Хотя погоди, какой я тебе слон, ты за языком-то следи!
>> **Елизавета Викторовна (старшая медсестра)**

> Я ничего такого не говорил!
>> **Стажер**

> Хах, да шучу я. Все еще не привык к моему специфичному чувству юмора? Ну да ладно, всему свое время.
> 
> Тебе там что-то попробовать новое нужно? А у меня как раз есть для тебя задача. В прошлый раз ты разработал программу для формирования
> расписания и добавления туда пациентов. Но это все для одного расписания, да к тому же было две программы для этого.
> Я бы хотела иметь возможность создавать несколько расписаний под разных врачей и добавлять пациентов в любое из них.
> И при этом чтобы все работало из одной программы!
> 
> Судя по твоему лицу, тебе нужно покумекать над этим. Иди подумай, подготовься, я вернусь к тебе чуть позже.
>> **Елизавета Викторовна (старшая медсестра)**

## Chapter II

### Принципы ООП

Даже говорить не нужно, что у таинственного админа, естественно, нашлись записи об ООП.

> Скажу сразу, тема может быть сложной для понимания, но постараюсь хоть немного приоткрыть завесу тайны. Давай начнем с того, что
> **ООП** — это стиль программирования. Отсюда вопрос: а что такое стили программирования?
> 
> Давай посмотрим на пару стилей и примеры. Например, тот код, который ты писал в самом начале, имел **императивный** стиль.
> Это такой стиль, когда ты просто пишешь последовательно инструкции в программе. Когда добавились функции, стиль твоего кода стал **процедурным**, 
> что тоже подразумевает последовательные инструкции, но часть из них уже обернута в отдельные функции (процедуры).
> 
> Так вот, **объектно-ориентированное программирование** — это еще один стиль. Стиль этот характеризуется тем, что твой код
> описан через **классы** и **объекты этих классов**. Что же такое классы и объекты? Я попробую привести пару аналогий и примеров, которые
> должны помочь тебе разобраться в этом.
> 
> Классическая аналогия для классов и объектов следующая: представь, что класс — это чертеж. Например, вот чертеж конуса.
> Чтобы построить любой конус, нужен диаметр основания (*a*) и высота конуса (*b*).
> ![drawing](misc/images/drawing.png)
> 
> Подставив любые значения *a* и *b*, можно построить любой неусеченный конус.
> Так вот, класс — это чертеж, который описывает что-то, в данном случае конус. Конкретный же конус с размерами *a = 1см* и *b = 2см* — это объект класса Конус.
> Или, другими словами, **экземпляр** этого класса. Словосочетание **экземпляр класса** идентично по смыслу словосочетанию **объект класса**.
> 
> Стало ли понятнее? Не уверен. Давай последуем совету из классики советского кинематографа: «Тренируйся лучше... на кошках!».
> Чертеж — это хорошее объяснение, но не все в нашем мире можно изобразить или описать с помощью чертежей. Возьмем, к примеру, кошку.
> Можно ли сделать чертеж кошки? Вопрос философский.
>
> Возьмем другую аналогию для описания класса. Класс — это описание
> какого-то понятия или явления. Существует понятие «Кошка». Оно характеризует определенное животное. Подумай о кошке. Ты явно представляешь себе
> что-то мохнатое, усатое, возможно, недовольное. Так вот, Кошка в целом — это класс.
> ```python
> class Cat:
>   ...
> ```
> А вот конкретное меланхоличное существо, живущее у тебя дома (ну или у кого-то другого), по кличке Мистер Царапкин — это объект класса `Cat`.
> ```python
> mister_scratchkin = Cat()
> ```
> Сам класс `Cat` может характеризоваться цветом шерсти, кол-вом килограммов счастья, породой и т. д. Но наш Мистер Царапкин уже
> имеет конкретную породу (чистокровный дворовый), вес (добрые 7 кг) и цвет (мокрого асфальта). То есть класс — это описание чего-то
> общего, имеющего определенные характеристики, а объект класса — это что-то конкретное с конкретными характеристиками этого класса.
> 
> Концепт, надеюсь, понятен, но где это можно применить в коде и, главное, зачем? Допустим, ты хочешь описать пациентов в своем коде с помощью имени и даты рождения.
> Как это можно сделать? Можно так:
> ```python
> patient_1_name = 'Вася'
> patient_1_birthday = '1993-10-03'
> 
> patient_2_name = 'Петя'
> patient_2_birthday = '1995-12-25'
> ```
> Или так:
> ```python
> dict_patient = {
>   1: {
>       "name": "Вася",
>       "birthday": "1993-10-03",
>      },
>   2: {
>       "name": "Петя",
>       "birthday": "1995-12-25",
>      },
> }
> ```
> А можно представить пациента как определенную общую сущность — класс. А конкретные Вася и Петя будут уже объектами этого класса.
> ```python
> class Patient:
>   ...
> ```
> Теперь можно создать 2 конкретных пациентов:
> ```python
> patient_1 = Patient()
> patient_2 = Patient()
> ```
> Классы и их экземпляры имеют характеристики — **атрибуты**. Атрибуты класса и атрибуты объектов — это не одно и то же.
> Атрибуты класса одинаковы для всех объектов. К ним можно обратиться через сам класс или через объекты класса через точку.
> В качестве атрибута класса может служить описание: «Этот класс и объекты класса описывают пациентов поликлиники».
> Атрибуты объекта же могут отличаться от объекта к объекту. Например, имя первого и второго пациента — это атрибут этих объектов.
> Этот атрибут можно задать так:
> ```python
> patient_1.name = 'Вася'
> patient_2.name = 'Петя'
> ```

### Задание 1

Пока мозг не вскипел, нужно попробовать использовать эти классы для какой-нибудь знакомой задачи.
Как раз можно начать делать задачу с расписанием для Елизаветы Викторовны.

1. В файле *src/schedule_1.py* нужно создать класс `Schedule`. В этом классе создать атрибут класса `description`, содержащий следующую строку:
`Class for working with schedules of doctors`.
2. В файле *src/task_1.py* необходимо реализовать функцию `main`, в которой прописать всю основную логику. То есть все пункты, в которых явно 
не указано, где их нужно реализовывать, реализовывать в функции `main`.
3. Вызов функции `main` осуществить в блоке `if __name__ == "__main__":` (**далее во всех заданиях пункт 2 и 3 ОБЯЗАТЕЛЬНЫ!**).
4. Врач вводит в клавиатуры:
   - ФИО первого врача — `ivanov ivan ivanovich`;
   - специальность первого врача — `therapist`;
   - ФИО второго врача — `petrov petr petrovich`;
   - специальность второго врача — `lor`.
5. При вводе с клавиатуры врач должен видеть следующие записи в разных инпутах (порядок инпутов обязателен):
   - `Enter the full name of the first doctor: `;
   - `Enter the speciality of the first doctor: `;
   - `Enter the full name of the second doctor: `;
   - `Enter the speciality of the second doctor: `.
6. ФИО и специальность необходимо привести к виду: первая буква каждого слова — заглавная, остальные строчные (**далее во всех заданиях данное приведение ко всем словам ОБЯЗАТЕЛЬНО!**).
7. Создать два экземпляра класса `Schedule` и в каждый из них завести атрибуты `doctor_name` и `doctor_speciality`, в которые записать ФИО и специальность двух врачей соответственно.
8. Вывести на экран, используя обращение к атрибутам объектов и классов, следующую информацию: описание класса `Schedule`, ФИО 1 врача, специальность 1 врача, ФИО 2 врача, специальность 2 врача. Пример:
    ```
    Class for working with schedules of doctors
    Ivanov Ivan Ivanovich
    Therapist
    Petrov Petr Petrovich
    Lor
    ```
9. Функция `main` должна возвращать два созданных объекта класса (необходимо для проверки), пример:
    ```python
    return schedule_1, schedule_2
    ```

## Chapter III

### Метод init

> На самом деле, задавать новые атрибуты после создания класса напрямую не очень хороший тон. Вдруг у первого пациента ты задашь оба атрибута — имя и день рождения,
> а у второго пациента только имя. И вот уже двух пациентов описывают разные атрибуты. Это неправильно. Все атрибуты лучше определять внутри определения класса.
> 
> Как же это сделать? Помимо атрибутов, внутри классов еще есть **методы** — это функции, которые описаны внутри класса.
> ```python
> class Patient:
>   def example_method(self):
>       ...
> ```
> Среди этих методов есть так называемые **магические методы**, которые с двух концов обернуты двойной нижней чертой. Наверное, самый
> популярный среди них — это метод `__init__`:
> ```python
> class Patient:
>   def __init__(self):
>       ...
> ```
> Данный метод вызывается автоматически, когда создается экземпляр класса, т. е. во время `patient_1 = Patient()`.
> В этот метод можно также передать аргументы (как в обычные функции), которые как-то используются внутри него.
> Метод `__init__` вызывается неявно, а аргументы в него надо передавать следующим образом:
> ```python
> class Patient:
>   def __init__(self, a):
>       self.a = a
> 
> patient_1 = Patient(a=1)
> ```
>  Часто внутри этого метода определяются атрибуты объекта.
> 
> Самая главная загадка здесь — это ключевое слово `self`. При формировании классов данное ключевое слово будет встречаться постоянно.
> Что оно значит, подробнее можно поискать в Гугле. Если же кратко и просто, то это слово, которое обозначает экземпляр класса.
> То есть `self.a = a` значит, что в случае конкретного объекта вместо `self` под капотом подставится объект, например,
> `patient_1.a = a` или `patient_2.a = a`. То есть это ключевое слово как бы описывает работу с конкретным объектом класса.

### Задание 2

Нужно попробовать переписать код так, чтобы не задавать атрибуты класса напрямую.
1. В файле *src/schedule_2.py* необходимо создать класс `Schedule`. В этом классе создать:
    - атрибут класса `description`, содержащий следующую строку: `Class for working with schedules of doctors`;
    - метод `__init__`, который принимает два аргумента и внутри определяет два атрибута объектов: `doctor_name` и `doctor_speciality`.
2. Выполнить пункты 2-6 из Задания 1, но в файле *src/task_2.py*. Приведение к регистру ФИО и специальности необходимо делать в функции `main`, НЕ внутри класса `Schedule` (приведение к нужному регистру — см. пункт 6 Задания 1)!!! 
3. Создать два экземпляра класса `Schedule`. При создании передать введенные с клавиатуры значения в аргументы метода `__init__`.
4. Вывести на экран, используя обращение к атрибутам объектов и классов, следующую информацию: описание класса `Schedule`, ФИО 1 врача, специальность 1 врача, ФИО 2 врача, специальность 2 врача. Пример:
    ```
    Class for working with schedules of doctors
    Ivanov Ivan Ivanovich
    Therapist
    Petrov Petr Petrovich
    Lor
    ```
5. Функция `main` НИЧЕГО не возвращает в данной задаче.

## Chapter IV

### Методы объекта

> Все методы, которые совершаются над конкретными объектами, называются **методами объекта**. 
> В каждый из них первым аргументом необходимо передавать ключевое слово **self**. Почему же методы объекта описываются в классе?
> Все просто: потому что методы объекта, описанные внутри класса, будут присутствовать во всех экземплярах данного класса.
> 
> Метод объекта можно вызвать через сам объект:
> ```python
> class Patient:
>   def example_method(self, b):
>       ...
> 
> patient_1 = Patient()
> patient_1.example_method(b=10)
> ```
> 
> Внутри методов объекта можно использовать атрибуты объекта, которые в нем хранятся:
> ```python
> class Patient:
>   def __init__(self, a):
>       self.a = a
> 
>   def sum_with_const(self, b):
>       return self.a + b
> 
> patient_1 = Patient(1)
> result = patient_1.sum_with_const(b=10)
> print(result)
> ```
> В данном примере на экран выведется `11`.

### Задание 3

Нужно попробовать реализовать какой-нибудь метод. Можно взять что-то из прошлого проекта. Например, задание с формированием меток времени. Тогда нужно:
1. В файле *src/schedule_3.py* создать класс `Schedule`. В этом классе создать:
    - атрибут класса `description`, содержащий следующую строку: `Class for working with schedules of doctors`;
    - метод `__init__`, который принимает пять аргументов и внутри определяет пять атрибутов объектов: `doctor_name`, `doctor_speciality`,
`time_start`, `time_end` и `duration`;
    - метод `get_list_timestamps_for_schedule`, который формирует и возвращает список меток времени: `['08:00', '08:30', '09:00', '09:30', '10:00', '10:30']` (возвращает, а не выводит на экран!).
Данный метод не должен принимать аргументы, а может использовать только атрибуты объекта. Если непонятно, как формировать данный список, можно вернуться к Заданию 1 и 2 прошлого проекта.
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_3.py*.
3. Врач вводит с клавиатуры:
   - ФИО первого врача — `petrov petr petrovich`;
   - специальность первого врача — `therapist`;
   - время первого приема — `08:00`;
   - время последнего приема — `10:30`;
   - продолжительность одного приема в минутах — `30`,\
и так для двух врачей.
4. Пример ввода (после вводов всей информации для каждого врача необходимо выводить на экран разделительную полосу, состоящую из 50 черточек `-`):
    ```
    Enter the full name of the doctor: petrov petr petrovich
    Enter the speciality of the doctor: therapist
    Enter the time of first appointment (08:00): 08:00
    Enter the time of last appointment (13:30): 10:30
    Enter the duration of one appointment in minutes (15): 30
    --------------------------------------------------
    Enter the full name of the doctor: ivanov ivan ivanovich
    Enter the speciality of the doctor: lor
    Enter the time of first appointment (08:00): 13:30
    Enter the time of last appointment (13:30): 16:00
    Enter the duration of one appointment in minutes (15): 30
    --------------------------------------------------
    ```
5. Каждый ввод из предыдущего пункта выводить в отдельном инпуте. Черточки выводить через принт.
Приведение к регистру ФИО и специальности необходимо делать в функции `main`. Также в функции `main` необходимо переводить продолжительность приема к целому числу (НЕ внутри класса `Schedule`)!
6. Для каждого врача создать свой экземпляр класса `Schedule`. При создании передать введенные с клавиатуры значения в аргументы метода `__init__`.
7. Вызвать у двух экземпляров метод `get_list_timestamps_for_schedule` и получить списки временных меток для каждого экземпляра.
8. Вывести их на экран следующим образом:
    ```
    First list of timestamps - ['08:00', '08:30', '09:00', '09:30', '10:00', '10:30']
    Second list of timestamps - ['13:30', '14:00', '14:30', '15:00', '15:30', '16:00']
    ```

## Chapter V

### Приватные методы

> Помимо обычных методов и магических (таких как `__init__`), существуют еще разные полезные типы методов.
> Одни из этих типов — это **приватные методы**. Приватные методы начинаются на два подчеркивания, но не заканчиваются ими,
> в отличие от магических методов.
> 
> Приватные методы доступны внутри описания класса, но к ним нельзя напрямую обратиться через объекты. Поэтому они и приватные.
> Зачем это нужно? Часто обычные методы в классе внутри себя могут использовать другие методы, которые нужны только
> для исправной работы первых. Пользователю напрямую они не нужны, поэтому их на всякий пожарный закрывают.
> ```python
> class Patient:
>   def __init__(self, a):
>       self.a = a
> 
>   def sum_with_const(self, b):
>       c = self.__multiplication_5(b)
>       return c + b
> 
>   def __multiplication_5(self, b):
>       return self.a * b
> 
> patient_1 = Patient(2)
> result = patient_1.sum_with_const(10)
> print(result)
> ```
> В данном примере на экран выведется `30`.\
> Попробуй обратиться к методу `patient_1.__multiplication_5(10)` напрямую и посмотри на результат.

### Задание 4

Можно попробовать данные методы, продолжая делать расписание. В этот раз можно сформировать уже полноценный шаблон. Для этого нужно:
1. В файле *src/schedule_4.py* создать класс `Schedule`. В этом классе создать:
    - атрибут класса `description`, содержащий следующую строку: `Class for working with schedules of doctors`;
    - метод `__init__`, который принимает пять аргументов и внутри определяет пять атрибутов объектов: `doctor_name`, `doctor_speciality`,
`time_start`, `time_end` и `duration`;
    - приватный метод `__get_list_timestamps_for_schedule`, который формирует и возвращает список меток времени — `['08:00', '08:30', '09:00', '09:30', '10:00', '10:30']`.
Данный метод не должен принимать аргументы, а может использовать только атрибуты объекта. Если непонятно, как формировать данный список, можно вернуться к Заданию 1 и 2 прошлого проекта.
Данный метод должен вызываться внутри следующего метода `create_schedule`;
    - метод `create_schedule`, который должен сформировать шаблон расписания в виде списка списков: `[['Time', 'Patient', 'The patient visited the doctor'], ['08:00', '', 'No'], ['08:30', '', 'No'], ['09:00', '', 'No'], ['09:30', '', 'No']]`.
Данное расписание должно записываться в атрибут объекта `schedule_list`. Метод не должен принимать никаких аргументов и ничего возвращать;
    - метод `print_schedule`, который выводит на экран расписание с помощью библиотеки `tabulate` в формате `github`. Метод не должен принимать никаких аргументов и ничего возвращать, только выводить на экран.
Пример:
        ```
        | Time   | Patient   | The patient visited the doctor   |
        |--------|-----------|----------------------------------|
        | 08:00  |           | No                               |
        | 08:30  |           | No                               |
        | 09:00  |           | No                               |
        | 09:30  |           | No                               |
        | 10:00  |           | No                               |
        | 10:30  |           | No                               |
        ```
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_4.py*.
3. Пункты 3-6 из Задания 3 также актуальны и в этом задании.
4. В функции `main` создать два расписания с помощью метода `create_schedule`.
5. С помощью метода `print_schedule` вывести расписания для двух врачей следующим образом (добавив заголовки «First schedule» и «Second schedule»):
    ```
    First schedule
    | Time   | Patient   | The patient visited the doctor   |
    |--------|-----------|----------------------------------|
    | 08:00  |           | No                               |
    | 08:30  |           | No                               |
    | 09:00  |           | No                               |
    | 09:30  |           | No                               |
    | 10:00  |           | No                               |
    | 10:30  |           | No                               |
    Second schedule
    | Time   | Patient   | The patient visited the doctor   |
    |--------|-----------|----------------------------------|
    | 13:30  |           | No                               |
    | 14:00  |           | No                               |
    | 14:30  |           | No                               |
    | 15:00  |           | No                               |
    | 15:30  |           | No                               |
    | 16:00  |           | No                               |
    | 16:30  |           | No                               |
    | 17:00  |           | No                               |
    | 17:30  |           | No                               |
    ```

## Chapter VI

### Постановка задачи

Пока ты попиваешь чаек, укладывая в голове полученные знания об ООП, ты не замечаешь, как в кабинет входит Елизавета Викторовна.

> Что-то я забегалась, полдня уже все-таки прошло. Ну как, обдумал мою задачу?
>> **Елизавета Викторовна (старшая медсестра)**

> Да, опробовал новый подход, который советовал главврач.
>> **Стажер**

> Ну и отличненько. Смотри, в чем моя хотелка. Я хочу, чтобы по уже доброй традиции после запуска программа бы мне предлагала разные опции.
> 
> Первая опция — это создание пустого расписания для конкретного врача. То есть ввела ФИО, специальность, время первого приема, последнего и продолжительность,
> а мне сформировалось для этого врача пустое расписание. При этом я хочу создавать много расписаний под всех врачей.
> 
> Вторая опция — добавление пациента в расписание конкретного врача. То есть выбрала опцию, ввела ФИО врача, к кому хочу записать,
> время записи и ФИО пациента. И пусть после выбора врача мне показывается текущее расписание и после добавления пациента тоже, чтобы
> я удостоверилась, что пациент вписан.
> 
> Третья опция — это завершение программы. Однако перед тем как ее завершить, пусть все сформированные очереди запишутся в csv-файлы,
> допустим, в папку *src/*. При этом сами файлы назови так: 'Фамилия_Имя_Отчество_Специальность.csv'. Например, `Maximov_Maxim_Maximovich_Ophthalmologist.csv`.
> 
> Все понятно, касатик?
>> **Елизавета Викторовна (старшая медсестра)**

> Кажется, да.
>> **Стажер**

### Задание 5

Немного покумекав, ты решаешь разбить эту задачу на две подзадачи. В первой подзадаче ты планируешь реализовать первую и третью опции, которые хочет старшая медсестра.

Нужно заранее предусмотреть, как сохранять объекты пациентов, чтобы можно было к ним потом обратиться (добавить пациента).
С учетом того, что неизвестно, сколько расписаний захочет добавить медсестра каждый день. Можно попробовать использовать для этого коллекцию, 
например, словарь (интересно, можно ли в качестве значения ключа запихнуть объект?).

Помимо этого, ты понимаешь, что в данном случае можно формировать пустое расписание сразу при создании объекта класса, а не вызывать метод `create_schedule` вручную. Так, получается, что тебе нужно:
1. В файле *src/schedule_5.py* создать класс `Schedule`. В этом классе создать:
    - атрибут класса `description`, содержащий следующую строку: `Class for working with schedules of doctors`;
    - метод `__init__`, который принимает пять аргументов и внутри определяет шесть атрибутов объектов: `doctor_name`, `doctor_speciality`,
`time_start`, `time_end`, `duration` и `schedule_list`. Последний атрибут `schedule_list` должен считаться с помощью ПРИВАТНОГО метода `__create_schedule`;
    - приватный метод `__get_list_timestamps_for_schedule`, который формирует и возвращает список меток времени.
Данный метод не должен принимать аргументов, а может использовать только атрибуты объекта. Данный метод должен вызываться внутри следующего метода `__create_schedule`;
    - приватный метод `__create_schedule`, который должен сформировать шаблон расписания в виде списка списков: `[['Time', 'Patient', 'The patient visited the doctor'], ['08:00', '', 'No'], ['08:30', '', 'No'], ['09:00', '', 'No'], ['09:30', '', 'No']]`
и ВОЗВРАЩАТЬ его (никаких аргументов метод не принимает);
    - метод `print_schedule`, который выводит на экран расписание с помощью библиотеки `tabulate` в формате `github`. Метод не должен принимать никаких аргументов и ничего возвращать, только выводить на экран;
    - метод `write_to_csv`, который записывает расписание в папку *src/* в виде csv-файла в следующем виде: `Фамилия_Имя_Отчество_Специальность.csv` (пример: `Maximov_Maxim_Maximovich_Ophthalmologist.csv`).
Метод не должен принимать каких-либо аргументов и не должен ничего возвращать.
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_5.py*.
3. При запуске программы пользователь должен видеть предложение ввода двух опций, огороженное с двух сторон 50 черточками `-` (введенное через **один** инпут, а не принт!):
    ```
    --------------------------------------------------
    Enter:
     - 1, if you want to create a schedule;
     - 2, if you want to complete the program.
    --------------------------------------------------
    ```
4. При выборе опции 1 необходимо запросить у пользователя данные о расписании (см. пункты 3-5 Задания 3).
5. Далее необходимо с помощью этих данных для каждого нового расписания создать объект класса `Schedule`. При этом можно заранее продумать, как потом найти нужный объект по ФИО врача и где эти объекты хранить в принципе во время работы программы.
6. После ввода всех данных для опции 1 пользователь снова должен видеть приглашение к выбору опции (пункт 3). И так до тех пор, пока не будет выбрана опция 2.
7. При выборе опции 2 необходимо сохранить все расписания в папку *src/* с помощью метода объектов `write_to_csv` в виде: `Фамилия_Имя_Отчество_Специальность.csv` (пример: `Maximov_Maxim_Maximovich_Ophthalmologist.csv`) и после этого **завершить программу**.

P.S. Перед запуском всегда необходимо проверять, что правильно задана рабочая папка проекта (папка репозитория), а пути в коде
указаны относительно папки проекта.

### Задание 6

Отлично, теперь можно перейти к реализации опции для добавления пациента. Как же это лучше всего сделать?
Можно попробовать так:
1. В файле *src/schedule_6.py* создать класс `Schedule`. В этом классе создать:
    - атрибут класса `description`, содержащий следующую строку: `Class for working with schedules of doctors`;
    - метод `__init__`, который принимает пять аргументов и внутри определяет шесть атрибутов объектов: `doctor_name`, `doctor_speciality`,
`time_start`, `time_end`, `duration` и `schedule_list`. Последний атрибут `schedule_list` должен считаться с помощью ПРИВАТНОГО метода `__create_schedule`;
    - приватный метод `__get_list_timestamps_for_schedule`, который формирует и возвращает список меток времени.
Данный метод не должен принимать аргументов, а может использовать только атрибуты объекта. Данный метод должен вызываться внутри следующего метода `__create_schedule`;
    - приватный метод `__create_schedule`, который должен сформировать шаблон расписания в виде списка списков: `[['Time', 'Patient', 'The patient visited the doctor'], ['08:00', '', 'No'], ['08:30', '', 'No'], ['09:00', '', 'No'], ['09:30', '', 'No']]`
и ВОЗВРАЩАТЬ его (никаких аргументов метод не принимает);
    - метод `print_schedule`, который выводит на экран расписание с помощью библиотеки `tabulate` в формате `github`. Метод не должен принимать никаких аргументов и ничего возвращать, только выводить на экран;
    - метод `write_to_csv`, который записывает расписание в папку *src/* в виде csv-файла в следующем виде: `Фамилия_Имя_Отчество_Специальность.csv` (пример: `Maximov_Maxim_Maximovich_Ophthalmologist.csv`).
Метод не должен принимать каких-либо аргументов и не должен ничего возвращать;
    - метод `add_patient_to_schedule`, который принимает два аргумента: время (`08:00`) и ФИО пациента (`ivanov ivan ivanovich`) и должен в атрибут `schedule_list` добавлять ФИО пациента во 2 колонку напротив переданного времени.
Если же такого времени нет, выводить на экран: `This time is not on the schedule!`. Необходимо не забыть обработать регистр ФИО пациента так же, как и до этого ФИО врачей. Метод не должен ничего возвращать!
2. Выполнить пункты 2-3 из Задания 1, но в файле *src/task_6.py*.
3. При запуске программы пользователь должен видеть предложение ввода трех опций, огороженное с двух сторон 50 черточками `-` (введенное через один инпут, а не принт!):
    ```
    --------------------------------------------------
    Enter:
     - 1, if you want to create a schedule;
     - 2, if you want to add a patient to a ready schedule;
     - 3, if you want to complete the program.
    --------------------------------------------------
    ```
4. Код для опции 1 и 3 должен остаться прежним.
5. При выборе опции 2 пользователь должен видеть список текущих сформированных расписаний в виде ФИО врачей (для которых они сформированы) в следующем виде:
    ```
    List of current schedules - Ivanov Ivan Ivanovich, Petrov Petr Petrovich
    ```
6. После этого вывода пользователь должен ввести ФИО врача, к которому он хочет записать пациента в следующем виде (не забываем обработать регистр):
    ```
    List of current schedules - Ivanov Ivan Ivanovich, Petrov Petr Petrovich
    Enter the full name of the doctor to whose schedule you want to add the patient:
    ```
7. После ввода ФИО врача необходимо выводить на экран следующую информацию: ФИО врача, его специальность и текущее расписание в следующем виде:
    ```
    Enter the full name of the doctor to whose schedule you want to add the patient: ivanov ivan ivanovich
    Doctor - Ivanov Ivan Ivanovich
    Speciality - Therapist
    | Time   | Patient   | The patient visited the doctor   |
    |--------|-----------|----------------------------------|
    | 08:00  |           | No                               |
    | 08:30  |           | No                               |
    | 09:00  |           | No                               |
    | 09:30  |           | No                               |
    | 10:00  |           | No                               |
    | 10:30  |           | No                               |
    ```
8. После вывода данной информации необходимо запросить у пользователя время, куда хочется записать пациента и ФИО пациента в разных инпутах:
    ```
    Enter the time you want to schedule the patient, it must be in the schedule (08:00):
    Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich):
    ```
9. После ввода ФИО пациента необходимо добавить его в расписание, вывести на экран обновленное расписание и снова предложить опции для ввода:
    ```
    Enter the time you want to schedule the patient, it must be in the schedule (08:00): 08:30
    Enter the full name of patient separated by a space (Ivanov Ivan Ivanovich): sidorov sidor sidorovich
    | Time   | Patient                  | The patient visited the doctor   |
    |--------|--------------------------|----------------------------------|
    | 08:00  |                          | No                               |
    | 08:30  | Sidorov Sidor Sidorovich | No                               |
    | 09:00  |                          | No                               |
    | 09:30  |                          | No                               |
    | 10:00  |                          | No                               |
    | 10:30  |                          | No                               |
    --------------------------------------------------
    Enter:
     - 1, if you want to create a schedule;
     - 2, if you want to add a patient to a ready schedule;
     - 3, if you want to complete the program.
    --------------------------------------------------
    ```
10. Добавление пациента и вывод расписания на экран в опции 2 необходимо осуществить с помощью методов объектов `add_patient_to_schedule`и `print_schedule`.

P.S. Перед запуском всегда необходимо проверять, что правильно задана рабочая папка проекта (папка репозитория), а пути в коде указаны относительно папки проекта.

> Пример работы программы можно посмотреть в файле *materials/example_of_work.txt*.
>> **Голос свыше**

## Chapter VII

### Задание 7

Ты завершаешь программу, тестируешь ее и отдаешь благодарной Елизавете Викторовне. 

Все, что тебе остается на сегодня — это запушить все наработки в GitLab в ветку `develop`, включая все файлы *src/schedule_№.py*.
Файлы с расширением *.csv* пушить не нужно.

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
