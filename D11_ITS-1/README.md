# Объекты... везде объекты

## Аннотация

Данный проект позволит тебе подробнее изучить, как устроен Питон, типы данных в нем и почему все в Питоне — это объекты. 

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Объекты как модель данных](#объекты-как-модель-данных) \
    2.2. [Задание 1](#задание-1)
3. [Chapter II](#chapter-ii) \
    3.1. [Интернированные объекты](#интернированные-объекты) \
    3.2. [Задание 2](#задание-2) \
    3.3. [Задание 3](#задание-3)
4. [Chapter IV](#chapter-iv) \
    4.1. [Изменяемые и неизменяемые типы данных](#изменяемые-и-неизменяемые-типы-данных) \
    4.2. [Задание 4](#задание-4) \
    4.3. [Задание 5](#задание-5) 
5. [Chapter V](#chapter-v) \
    5.1. [Копирование объектов](#копирование-объектов) \
    5.2. [Задание 6](#задание-6) 
6. [Chapter VI](#chapter-vi) \
    6.1. [Ключевое слово del](#ключевое-слово-del)
7. [Chapter VII](#chapter-vii) \
    7.1. [Задание 7](#задание-7) 

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер: 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

> Как же хочется спать... Сейчас бы вздремнуть еще часочек, а не вот это всё...
>> **Стажер**

> Проснись и пой! Проснись и пой!\
> Попробуй в жизни хоть раз\
> Не выпускать улыбку из открытых глаз!
>> **Главврач, резко возникая у тебя за спиной и напевая на ухо**

Ты вздрагиваешь и с дергающимся глазом оборачиваешься к нему.

> Доброе утро! Тест на возраст, знаешь ли ты эту песню и откуда она?! Что?! Нет?! Ох, уж эта молодежь, классику не знает!
> 
> Ладно, ближе к делу. Знаешь, мне кажется, что ты уже довольно неплохо погрузился в Питон, и самое время погрузиться еще
> чуть глубже. Я даже специально позвал своего друга, который чуть больше шарит в Питоне, чтобы он провел для тебя это погружение. Он должен появиться с
> минуты на минуту. Пойду проверю, не пришел ли он.
>> **Главврач**

Главврач выходит из кабинета, и через какое-то время в дверь кто-то входит.

> Молодой человек, доброе утро! Это ведь вы тут постигаете дзен IT в его змеиной ипостаси?
> 
> Я друг вашего главврача, он меня позвал, чтобы помочь вам раскрыть некоторые особенности Питона.
>> **Чарввалг**

> Сэр, вы же в курсе, что накладные усы, нос с бородавкой, очки и шляпа — не лучший способ поменять внешность?
>> **Стажер**

> Не понимаю, о чем это вы, дорогой мой! Но давайте перейдем ближе к делу.
>> **Чарввалг**

> ...
>> **Стажер**

## Chapter II

### Объекты как модель данных

> Все, что я тебе буду сегодня рассказывать, может поначалу взорвать тебе мозг. Не переживай, это норма, при наличии времени и старания
> во всем всегда можно разобраться!
> 
> Я хочу с тобой поговорить немного о следующей фразе: «Все в Python — это объекты». Ты уже должен знать, что объект — это экземпляр какого-то класса.
> Так вот, почти всё в Питоне является экземпляром какого-то класса или как-то связано с ним. Очень интересно, но ничего не понятно, думаешь, наверное, ты.
> 
> Давай возьмем пример. Выполни вот этот код:
> ```python
> print(type(4))
> ```
> Встроенный метод **type** показывает, к какому типу (или, можно сказать, классу относится сущность). При выполнении этого кода видно, что
> 4 относится к классу int. Заметь, к КЛАССУ! Что, если я скажу, что 4 — это ОБЪЕКТ класса int. Мозг уже должен начать трещать по швам на этом моменте.
> 
> Что же на самом деле происходит, когда Питон встречает 4 в коде? Вот тебе очень упрощенное объяснение, но тем не менее. Существует класс int.
> Когда интерпретатор (программа, которая фактически и есть Питон), вернее, его часть, отвечающая за анализ кода, бежит по тексту и видит целое число 4, то интерпретатор создает объект класса int.
> Где в качестве значения этого объекта (фактически одного из его аргументов) вписывается число 4.
> При этом в оперативной памяти компьютера выделяется место под этот объект. Можно грубо себе представить, что в оперативную память кладется
> некий контейнер (объект). Каждый объект (включая нашу четверку) имеет 3 составляющие:
> 
> ![object_struct](misc/images/object_struct.png)
> 
> Про тип и значение я уже упомянул, что же такое идентификатор? Это целое число, которое уникально для каждого объекта и которое,
> упрощенно говоря, является адресом этого объекта в памяти. То есть с помощью этого числа легко найти объект и его значение в памяти компьютера. Посмотреть его можно с помощью встроенной функции **id**.
> ```python
> print(id(4))
> ```
> А теперь самое интересное: что происходит, когда мы пишем в коде следующее?
> ```python
> a = 4
> ```
> Как уже говорилось, сначала создается объект класса (типа) int со значением 4 внутри и уникальным id. А в переменную `a`
> по факту кладется **id** этого объекта (то есть адрес в памяти). Говорят, что переменная `a` ССЫЛАЕТСЯ на объект 4 в памяти.
> При этом при обращении к `a` напрямую мы видим только значение этого объекта. Упрощенно можно себе представить такую картину:
> 
> ![object_oper](misc/images/object_oper.png)
> 
> В Питоне бывает, что одни и те же переменные на самом деле ссылаются на одни и те же объекты в памяти. Чтобы это проверить,
> используется ключевое слово **is**. `a is b` эквивалентно `id(a) == id(b)`.
> Примером таких одинаковых ссылок может служить следующий код:
> ```python
> a = 4
> b = 4
> print(a is b)
> ```
> Или же самое распространенное:
> ```python
> b = a 
> ```
> В `b` будет лежать та же ссылка на тот же объект, что и в `a`. Выглядит это примерно так:
> 
> ![assignment](misc/images/assignment.png)
> 
> Нужно понимать, что выражение `a == b` сравнивает ЗНАЧЕНИЯ объектов `a` и `b`, а выражение `a is b` сравнивает именно идентификаторы, то есть
> показывает, ссылаются ли эти две переменные на один объект в памяти.
> 
> И еще одна картинка для понимания, но без комментариев:
> 
> ![new_value_to_variable](misc/images/new_value_to_variable.png)
>
>> **Чарввалг**

### Задание 1

> А теперь напиши код, с помощью которого ты сможешь визуально поиграться с тем, что происходит при присваивании таких
> простых типов данных, как целые числа, числа с плавающей точкой и булевый тип. 
> 
> Я хочу, чтобы ты сначала выбирал, какой тип данных будешь вводить.
> Далее вводил по порядку два элемента. Каждый элемент нужно привести к выбранному типу данных, записать в отдельную переменную, вывести их айдишники
> и посмотреть, ССЫЛАЮТСЯ ли эти переменные на один объект или два разных.
> 
> Само собой, интереснее всего посмотреть на это, когда ты вводишь с клавиатуры одинаковые сущности (например, две 4). При этом
> важно поиграться с разным диапазоном чисел. Ввести не только две 4, но и два -100, две 1000 и т. д. То есть абсолютно разные порядки, положительные и отрицательные числа и т. д.
> Для булевого типа вводи два одинаковых **True** или **False** с клавиатуры.
>> **Чарввалг**

Хм, ладно, получается, можно декомпозировать таску на следующие пункты:
1. В файле *src/task_1.py* необходимо реализовать функцию `main`, в которой прописать всю основную логику.
2. Вызов функции `main` осуществить в блоке `if __name__ == "__main__":` (**далее во всех заданиях, где нет готового кода, пункты 1 и 2 ОБЯЗАТЕЛЬНЫ! Меняется только файл.**).
3. Пользователь вводит с клавиатуры по порядку:
    - номер опции, для выбора типа данных;
    - первый элемент;
    - второй элемент.
4. Пользователь видит следующие строки при вводе (каждый подпункт должен быть реализован в своем инпуте, не принте, порядок обязателен):
    - ```
      Select what type of data you want to view:
       - 1, integer;
       - 2, float;
       - 3, bool.
    Текст выше весь должен быть реализован тоже в ОДНОМ инпуте (а не принте!). **В остальных заданиях все аналогично!**;
     - `Enter the first element: `;
     - `Enter the second element: `.
5. Ввод опции осуществляется на следующей строке после информации по ним (**обрати внимание на пример (!!!), в остальных заданиях все аналогично**)
6. После ввода двух элементов привести каждый к выбранному типу данных.
7. В случае если была выбрана опция, отличная от показанных, **завершить программу** (*делать это нужно ПОСЛЕ всех вводов, включая ввод двух элементов, чтобы сошлись автотесты*).
8. Далее необходимо выводить на экран следующую информацию:
    ```
    ID of the first element (<первый элемент>) - <id первого элемента>
    ID of the second element (<второй элемент>) - <id второго элемента>
    element_1 is element_2 -> <True или False>
9. Ты расписываешь себе пример работы программы, который выглядит так:
    ```
    Select what type of data you want to view:
     - 1, integer;
     - 2, float;
     - 3, bool.
    1
    Enter the first element: 4
    Enter the second element: 4
    ID of the first element (4) - 140703724135304
    ID of the second element (4) - 140703724135304
    element_1 is element_2 -> True
    ```
9. После написания программы необходимо ввести разнообразные элементы, особенно:
    - два разных элемента;
    - два одинаковых из всех 3 типов;
    - два одинаковых числа (маленьких и больших, положительных и отрицательных и т. д.);
    - два одинаковых булевых типа (`True` или `False`).

P.S. Дополнительно можно понять, почему в одних случаях две одинаковые переменные ссылаются на один объект, а в других — на два разных.

### Интернированные объекты

> Я очень надеюсь, что ты достаточно поэкспериментировал, чтобы увидеть странное поведение, например:
> ```python
> a = 4
> b = 4
> print(a is b)
> ```
> дает `True`, а вот уже
> ```python
> a = 1000
> b = 1000
> print(a is b)
> ```
> дает `False`. Если нет, то беги экспериментировать!
> 
> А вообще, все дело в том, что некоторые объекты в памяти являются **интернированными**. Это значит, что под определенные объекты в памяти создается
> лишь ОДИН объект, и все переменные в дальнейшем будут ссылаться только на этот объект в памяти. Обычно это самые часто используемые объекты,
> которые очень часто применяются в коде. Чтобы сократить объем памяти, они создаются в одном экземпляре.
> 
> Изучи, какие типы данных или какие значения определенных типов **интернируются в памяти**.
> 
>Для примера расскажу лишь об уже упомянутых 4 и 1000.
> 4 — это малое число, для которого при запуске интерпретатора сразу резервируется один объект в памяти, на него уже и ссылаются все переменные.
> А вот 1000 — это НЕинтернируемое число, и встретив новую 1000 в коде, Питон каждый раз создает в памяти новый объект со значением 1000.
> 
> **Интернирование** может также идти не при запуске интерпретатора, а при встрече в коде определенного значения. Так, например, работает с некоторыми видами строк.
> Строки особенны еще и тем, что мы можем интернировать любую строку вручную. То есть можно всегда сделать так, чтобы две строковые переменные
> с одинаковым значением ссылались на один объект в памяти. Напомню, что это нужно для экономии памяти в компьютере.
> 
> Как сделать ручное интернирование строк, посмотри сам, а то у меня уже язык болит трепаться.
>> **Чарввалг**

### Задание 2

> Предлагаю тебе расширить твою программу, добавив в нее новую опцию для выбора типа — строки. При этом пусть для строк сначала на экран выводятся их айдишники
> и соответствие одному объекту до ручного **интернирования**, а потом уже после.
> 
> При этом обязательно поэкспериментируй с разными видами двух одинаковых строк (одно слово, несколько слов через пробел, несколько слов через нижнее подчеркивание и т. д.) и посмотри на результат.
> 
> Есть еще один интересный момент: при вводе строк с клавиатуры они всегда будут разными объектами в памяти. Попробуй в качестве эксперимента
> задать эти две переменные с одинаковыми строками (такими же экспериментами) прямо в коде и посмотреть их айди и соответствия. Однако для проверки верни только ввод с клавиатуры!
>> **Чарввалг**

Какие-то слишком заумные слова пошли... Интернирование... Фиг еще запомнишь. Ладно, главное — запомнить суть, а не название!
Получается, что нужно сейчас сделать следующее:
1. Повторить пункты 1 и 2 из Задания 1, но в файле *src/task_2.py*.
2. Пользователь вводит с клавиатуры по порядку то же самое, что и в задании 1.
3. В опциях добавляется 4 опция для строк:
   ```
   Select what type of data you want to view:
    - 1, integer;
    - 2, float;
    - 3, bool;
    - 4, string.
   ```
4. После ввода двух элементов необходимо привести каждый к выбранному типу данных.
5. В случае если была выбрана опция, отличная от показанных, **завершить программу** (*делать это нужно ПОСЛЕ всех вводов, включая ввод двух элементов, чтобы сошлись автотесты*).
6. Далее необходимо выводить на экран следующую информацию для всех типов, КРОМЕ строк:
    ```
    ID of the first element (<первый элемент>) - <id первого элемента>
    ID of the second element (<второй элемент>) - <id второго элемента>
    element_1 is element_2 -> <True или False>
7. Для строк необходимо вывести результат до ручного интернирования, потом интернировать две строки и вывести результат после, при этом разделив эти выводы 50 черточками `-`:
    ```
    ID of the first element before interning (<первый элемент>) - <id первого элемента до интернирования>
    ID of the second element before interning (<второй элемент>) - <id второго элемента до интернирования>
    element_1 is element_2 -> <True или False>
    --------------------------------------------------
    ID of the first element (<первый элемент>) - <id первого элемента после интернирования>
    ID of the second element (<второй элемент>) - <id второго элемента после интернирования>
    element_1 is element_2 -> <True или False>
8. Ты расписываешь себе пример работы программы для строк, который выглядит так:
    ```
    Select what type of data you want to view:
     - 1, integer;
     - 2, float;
     - 3, bool;
     - 4, string.
    4
    Enter the first element: hello
    Enter the second element: hello
    ID of the first element before interning (hello) - 1674431114672
    ID of the second element before interning (hello) - 1674431114736
    element_1 is element_2 -> False
    --------------------------------------------------
    ID of the first element (hello) - 1674431114672
    ID of the second element (hello) - 1674431114672
    element_1 is element_2 -> True
    ```
9. После написания программы необходимо провести эксперименты с разными строками. При этом надо попробовать вместо ввода с клавиатуры задать две одинаковые строковые переменные прямо в коде, 
чтобы понять, когда и какие из них интернируются автоматически самим Питоном. Ввод с клавиатуры не интернирует эти строки автоматически.
10. После экспериментов задания переменных внутри кода необходимо все вернуть под ввод с клавиатуры (для проверок автотестами). Можно проводить эксперименты в отдельном файле, чтобы не трогать основной код.

P.S. Главврач в гриме подтвердил, что его тесты могут проверить, было ли интернирование или нет, лазейки ручными принтами не пройдут...

### Задание 3

> Помимо автоматического интернирования (как в случае малых чисел или булевого типа) и использования ручного интернирования с помощью
> встроенных библиотек (как в случае строк), можно написать и свой метод для интернирования. Это ничем не будет отличаться от 
> обычного кэширования (возможно, ты слышал, что это, если нет — погугли).
> 
> Для практики попробуй реализовать собственный метод для интернирования кортежей.
> 
>Как это будет работать: ты ввел с клавиатуры первый кортеж,
> интернировал его (добавил в кэш) с помощью написанного метода и записал в какую-то переменную. После ты ввел с клавиатуры тот же кортеж. По умолчанию без интернирования для него будет создан новый объект.
> Но если применить на нем написанный метод, в котором проверить, был ли такой кортеж уже интернирован, т. е. объект с таким значением уже существует (есть в кэше), то вместо создания нового объекта метод должен вернуть уже существующий объект.
> И этот объект уже связать с новой переменной.
>> **Чарввалг**

Вообще не очень понятно, что нужно делать. Похоже, сначала все же нужно разобраться, что такое интернирование, и постараться понять
принцип работы `sys.intern()`. Но если все-таки расписать какие-то ключевые моменты, то получится, что нужно:
1. Повторить пункты 1 и 2 из Задания 1, но в файле *src/task_3.py*. Допускается написание промежуточных функций, которые будут вызываться внутри функции `main`.
2. Пользователь вводит с клавиатуры по порядку то же самое, что и в прошлых заданиях (опцию и два элемента).
3. В опциях добавляется 5 опция для кортежей:
   ```
   Select what type of data you want to view:
    - 1, integer;
    - 2, float;
    - 3, bool;
    - 4, string;
    - 5, tuple.
   ```
4. Если была выбрана опция 5, то ввод для элементов меняется на следующий вид (каждый в своем инпуте, не принте!):
    ```
    Enter the items for the first collection, separated by commas and spaces (in this form - 1, 2, 3): 
    Enter the items for the second collection, separated by commas and spaces (in this form - 1, 2, 3): 
    ```
    Для остальных опций ввод элементов остается тем же.
5. После ввода двух элементов необходимо привести каждый к выбранному типу данных. В случае 5 опции к кортежу нужно привести введенную строку, вида — `1, 2, 3, 4`.
6. В случае если была выбрана опция, отличная от показанных, **завершить программу** (*делать это нужно ПОСЛЕ всех вводов, включая ввод двух элементов, чтобы сошлись автотесты*).
7. Необходимо написать функцию для интернирования кортежей, которую можно применять аналогично `sys.intern()` для строк.
Функция должна принимать кортеж, проверять, был ли такой же кортеж интернирован (условно добавлен в какой-то кэш) до этого, если да, то возвращать закэшированный уже существующий объект.
Если нет, то интернировать (кэшировать) его и его же возвращать.
8. Для остальных опций все выводы остаются теми же, для кортежей необходимо, как и для строк, вывести результат до ручного интернирования, 
потом интернировать (с помощью написанного метода) два кортежа и вывести результат после, при этом разделив эти выводы 50 черточками `-`:
    ```
    ID of the first element before interning (<первый элемент>) - <id первого элемента до интернирования>
    ID of the second element before interning (<второй элемент>) - <id второго элемента до интернирования>
    element_1 is element_2 -> False
    --------------------------------------------------
    ID of the first element (<первый элемент>) - <id первого элемента после интернирования>
    ID of the second element (<второй элемент>) - <id второго элемента после интернирования>
    element_1 is element_2 -> <True или False>
9. Ты расписываешь себе пример работы программы для кортежей, который выглядит так:
    ```
    Select what type of data you want to view:
     - 1, integer;
     - 2, float;
     - 3, bool;
     - 4, string;
     - 5, tuple.
    5
    Enter the items for the first collection, separated by commas and spaces (in this form - 1, 2, 3): 1, 2, 3
    Enter the items for the second collection, separated by commas and spaces (in this form - 1, 2, 3): 1, 2, 3
    ID of the first element before interning (('1', '2', '3')) - 2456377290880
    ID of the second element before interning (('1', '2', '3')) - 2456377317824
    element_1 is element_2 -> False
    --------------------------------------------------
    ID of the first element (('1', '2', '3')) - 2456377290880
    ID of the second element (('1', '2', '3')) - 2456377290880
    element_1 is element_2 -> True
    ```
   
## Chapter IV

### Изменяемые и неизменяемые типы данных

> Когда говорят о типах данных в Питоне, то часто еще упоминают деление этих типов на **неизменяемые** и **изменяемые**.
> Я тебе набросаю табличку, какие типы к какому классу относятся.
> 
> Неизменяемый тип данных | Изменяемый тип данных
> :-----------------------|:-----------------------
> int                     | list
> float                   | dict
> bool                    | set
> str                     |
> tuple                   |
> frozenset               |
> 
> Чем же они характеризуются? Перед тем как ответить на этот вопрос, давай посмотрим, как же коллекции хранятся в памяти.
> На картинке ниже приведен пример хранения списка в памяти. Попытайся осознать это.
> 
> ![object_list](misc/images/object_list.png)
> 
> А вот теперь можно вернуться к характеристике неизменяемых и изменяемых типов данных. Как говорит нам капитан Очевидность,
> объекты неизменяемых типов данных, как ни странно, нельзя изменить! Что это значит? Посмотри и выполни этот код:
> ```python
> a = 4
> print(id(a))
> a += 5
> print(id(a))
> ```
> В двух принтах выведутся разные айдишники. Да, 4 и 5 — это интернируемые объекты, но можно проверить то же самое на 1000 + 2000.
> Ответ будет такой же. Объект неизменяемого типа данных не меняется, а при добавлении к нему чего-то создается новый объект.
> 
> С неизменяемыми коллекциями — кортежами и фрозенсетами — все так же. В этих типах отсутствуют методы для добавления туда элементов.
> Можно, конечно, попытаться сделать так:
> ```python
> a = (1, 2, 3)
> print(id(a))
> a += (4, 5)
> print(id(a))
> ```
> Результат можешь проверить сам. 
> 
> А вот с изменяемыми все не так. В изменяемых ты МОЖЕШЬ изменять (да-да, тавтология, я знаю) уже существующие объекты.
> Во всех этих 3 типах есть методы для добавления туда новых элементов. Да и код:
> ```python
> a = [1, 2, 3]
> print(id(a))
> a += [4, 5]
> print(id(a))
> ```
> уже выдаст одинаковые айдишники. Кстати, если вместо `a +=` написать `a = a +`, то результат будет другой. Советую тоже погуглить почему.
> В случае же использования метода добавления напрямую получается:
> 
> ![mutable_oper](misc/images/mutable_oper.png)
>
> Но нужно понимать следующее: при присваивании в переменную изменяемого типа данных каждый раз создается новый объект в памяти.
> Даже если до этого в другую переменную был записан объект с таким же значением (например, тот же самый список):
> ```python
> a = [1, 2, 3]
> b = [1, 2, 3]
> ```
> Но при этом если внутри них лежат интернированные объекты, то может получиться следующее:
> 
> ![new_mutable](misc/images/new_mutable.png)
>
>> **Чарввалг**

### Задание 4

> Для начала давай добавим в твою прошлую программу опции для всех остальных типов: списков, множеств, замороженных множеств и словарей.
> Интернирование со строк и кортежей, кстати, можешь убрать, я думаю, что ты уже понял, про что оно. Заодно добавь в свой вывод для всех
> типов не только сравнение двух элементов через `is`, но и через `==`. Я думаю, тебе будет интересно посмотреть на результаты этих операций
> для двух одинаковых переменных, ссылающихся на изменяемые типы данных.
> 
> А, ну и добавь тип этих элементов в вывод.
>> **Чарввалг**

Итого, получается, что необходимо сделать следующее:
1. Повторить пункты 1 и 2 из Задания 1, но в файле *src/task_4.py*. Допускается написание промежуточных функций, которые будут вызываться внутри функции `main`.
2. Пользователь вводит с клавиатуры по порядку то же самое, что и в прошлых заданиях (опцию и два элемента).
3. В опции добавляются следующие пункты:
    ```
    Select what type of data you want to view:
     - 1, integer;
     - 2, float;
     - 3, bool;
     - 4, string;
     - 5, tuple;
     - 6, list;
     - 7, set;
     - 8, frozen set;
     - 9, dict.
    ```
4. Для опций 6-8 элементы запрашивать так же, как и для кортежей:
    ```
    Enter the items for the first collection, separated by commas and spaces (in this form - 1, 2, 3): 
    Enter the items for the second collection, separated by commas and spaces (in this form - 1, 2, 3): 
    ```
    Для опции 9 (dict), запрос осуществляется в следующем виде:
    ```
    Enter key:value pairs for the first dictionary, separated by commas and spaces (in this form - 1:3, 2:4, 5:6 - separated by colons, without spaces between :): 
    Enter key:value pairs for the second dictionary, separated by commas and spaces (in this form - 1:3, 2:4, 5:6 - separated by colons, without spaces between :): 
    ```
    Для остальных опций ввод элементов остается тем же.
5. После ввода двух элементов необходимо привести каждый к выбранному типу данных. В случае 6-8 опций к нужным типам приводится такая же строка, как и в кортежах. В случае словаря нужно привести, как пример, следующую строку `'1:3, 2:4, 5:6'` к словарю `{'1':'3', '2':'4', '5':'6'}`.
Приводить элементы внутри коллекций к каким-либо типам не нужно, пусть все они остаются в строковом типе.
6. В случае если была выбрана опция, отличная от показанных, **завершить программу** (*делать это нужно ПОСЛЕ всех вводов, включая ввод двух элементов, чтобы сошлись автотесты*).
7. Интернирование в строках и кортежах необходимо убрать и оставить только приведение к нужному типу.
8. Добавить сравнение двух введенных элементов через оператор `==` и добавить вывод типа приведенных элементов (с помощью **type**), при этом общий вывод для ВСЕХ опций будет следующий:
    ```
    ID of the first element (<первый элемент>) - <id первого элемента>
    ID of the second element (<второй элемент>) - <id второго элемента>
    Element type - <вывод функции type>
    element_1 == element_2 -> <True или False>
    element_1 is element_2 -> <True или False>
9. Ты расписываешь себе пример работы программы для:
    - целых чисел:
        ```
        Select what type of data you want to view:
         - 1, integer;
         - 2, float;
         - 3, bool;
         - 4, string;
         - 5, tuple;
         - 6, list;
         - 7, set;
         - 8, frozen set;
         - 9, dict.
        1
        Enter the first element: 1
        Enter the second element: 1
        ID of the first element (1) - 140703724135208
        ID of the second element (1) - 140703724135208
        Element type - <class 'int'>
        element_1 == element_2 -> True
        element_1 is element_2 -> True
    - списка:
        ```
        Select what type of data you want to view:
         - 1, integer;
         - 2, float;
         - 3, bool;
         - 4, string;
         - 5, tuple;
         - 6, list;
         - 7, set;
         - 8, frozen set;
         - 9, dict.
        6
        Enter the items for the first collection, separated by commas and spaces (in this form - 1, 2, 3): 1, 2, 3
        Enter the items for the second collection, separated by commas and spaces (in this form - 1, 2, 3): 1, 2, 3
        ID of the first element (['1', '2', '3']) - 1368952625728
        ID of the second element (['1', '2', '3']) - 1368952625600
        Element type - <class 'list'>
        element_1 == element_2 -> True
        element_1 is element_2 -> False
    - словаря:
        ```
        Select what type of data you want to view:
         - 1, integer;
         - 2, float;
         - 3, bool;
         - 4, string;
         - 5, tuple;
         - 6, list;
         - 7, set;
         - 8, frozen set;
         - 9, dict.
        9
        Enter key:value pairs for the first dictionary, separated by commas and spaces (in this form - 1:3, 2:4, 5:6 - separated by colons, without spaces between :): 1:10, 2:20, 3:30
        Enter key:value pairs for the second dictionary, separated by commas and spaces (in this form - 1:3, 2:4, 5:6 - separated by colons, without spaces between :): 1:10, 2:20, 3:30
        ID of the first element ({'1': '10', '2': '20', '3': '30'}) - 2102532723712
        ID of the second element ({'1': '10', '2': '20', '3': '30'}) - 2102534437824
        Element type - <class 'dict'>
        element_1 == element_2 -> True
        element_1 is element_2 -> False

P.S. Для остальных типов выводы аналогичны.

### Задание 5

> А теперь можно приступить и к заданию для демонстрации отличий неизменяемых типов от изменяемых.
> 
> Проще всего посмотреть на это, если попробовать взять объект и попытаться его изменить — прибавить число, добавить элемент в строку,
> добавить элемент в список, словарь и т. д. И посмотреть, останется ли id объекта тем же (то есть изменится ли сам объект) или
> же создастся новый.
> 
> Модифицируй программу с прошлого задания, оставив для ввода лишь один элемент с клавиатуры. При этом в зависимости от типа 
> элемента прибавляй (или добавляй) к нему какую-то константу. В случае неизменяемых коллекций можно прибавить другой кортеж:
> ```python
> a = (1, 2, 3)
> a += (4,)
> ```
> А в случае замороженного словаря объединить с другим замороженным словарем:
> ```python
> a = frozenset((1, 2, 3))
> a |= frozenset((-100,))
> ```
> 
> Для проверки, к какому типу относится объект, можно использовать встроенную функцию `isinstance()`.
>> **Чарввалг**

Ты набрасываешь перечень пунктов для реализации:
1. Повторить пункты 1 и 2 из Задания 1, но в файле *src/task_5.py*. Допускается написание промежуточных функций, которые будут вызываться внутри функции `main`.
2. Пользователь вводит с клавиатуры опцию для выбора типа (сделать все 9 опций) и ОДИН элемент.
3. Для опции 1-4 элемент запрашивать следующим образом:
    ```
    Enter the element: 
    ```
    Для опций 5-8 элемент запрашивать следующим образом:
    ```
    Enter the items for the collection, separated by commas and spaces (in this form - 1, 2, 3): 
    ```
    Для опции 9 (dict), запрос осуществляется в следующем виде:
    ```
    Enter key:value pairs for the dictionary, separated by commas and spaces (in this form - 1:3, 2:4, 5:6 - separated by colons, without spaces between :): 
    ```
4. После ввода элемента необходимо привести его к выбранному типу данных.
Приводить элементы внутри коллекций к каким-либо типам не нужно, пусть все они остаются в строковом типе.
5. В случае если была выбрана опция, отличная от показанных, **завершить программу** (*делать это нужно ПОСЛЕ всех вводов, включая ввод элемента,
чтобы сошлись автотесты*).
6. Интернирование нигде делать не нужно.
7. После приведения к выбранному типу введенной строки необходимо в зависимости от типа изменить этот объект следующим образом (имеется в виду, что нужно изменить ту же переменную):
    - для любых чисел вычесть `100`;
    - для строк конкатенировать со строкой `'-100'`;
    - для кортежей прибавлять кортеж `(-100,)` (внутри число);
    - для списков и множеств использовать их встроенные методы для добавления нового элемента — числа `-100`;
    - для замороженных множеств объединять с замороженным множеством `frozenset((-100,))`;
    - для словарей добавлять новую пару ключ-значения — `'-100': -100` (ключом является строка `'-100'`, значением — число `-100`).
8. Все операции, кроме списков, множеств и словарей, делать через оператор присваивания, т. е. не `a = a + 1`, а `a += 1`!
9. Вывод должен быть в следующем виде (разделительных черточек в каждой разделительной строке — 50 штук):
    ```
    Before the change:
    The element - <переменная, с приведенным к выбранному типу элементом до изменения>
    ID - <id, записанный в эту переменную до изменения>
    --------------------------------------------------
    After the change:
    The element - <переменная, с приведенным к выбранному типу элементом после изменения>
    ID - <id, записанный в эту переменную после изменения>
    --------------------------------------------------
    element_before is element_after -> <True или False>
    ```
10. Так как будет изменяться та же переменная, то необходимо не забыть, какой в ней был id до изменения.
11. Ты расписываешь себе пример работы программы для:
    - целых чисел:
        ```
        Select what type of data you want to view:
         - 1, integer;
         - 2, float;
         - 3, bool;
         - 4, string;
         - 5, tuple;
         - 6, list;
         - 7, set;
         - 8, frozen set;
         - 9, dict.
        1
        Enter the element: 10
        Before the change:
        The element - 10
        ID - 140703724135496
        --------------------------------------------------
        After the change:
        The element - -90
        ID - 1818383986672
        --------------------------------------------------
        element_before is element_after -> False
    - списка:
        ```
        Select what type of data you want to view:
         - 1, integer;
         - 2, float;
         - 3, bool;
         - 4, string;
         - 5, tuple;
         - 6, list;
         - 7, set;
         - 8, frozen set;
         - 9, dict.
        6
        Enter the items for the collection, separated by commas and spaces (in this form - 1, 2, 3): 1, 2, 3
        Before the change:
        The element - ['1', '2', '3']
        ID - 2359680326528
        --------------------------------------------------
        After the change:
        The element - ['1', '2', '3', -100]
        ID - 2359680326528
        --------------------------------------------------
        element_before is element_after -> True

P.S. Для булевого типа делать ничего не надо, его никак не изменить, и проверяться он не будет.\
P.P.S. Обязательно нужно посмотреть и проанализировать результаты работы программы для ВСЕХ опций.

## Chapter V

### Копирование объектов

> Так, надеюсь, ты уже достаточно познал сущность знака присваивания в Питоне и понял, что после
> ```python
> a = [1, 2, 3]
> b = a 
> ```
> `b` и `a` будут ссылаться на один объект в памяти. А если обе переменные ссылаются на один и тот же объект, то что же делать, если
> мы хотим создать не просто еще одну ссылку, а прямо КОПИЮ какого-то объекта. Допустим, для того чтобы один объект остался неизменным, а
> второй объект мы могли произвольно менять.
> 
> Вот здесь я оставлю всю работу на тебя. Я подготовил тебе файл *src/task_6.py* с 3 функциями, в каждой из которых нужно в переменную `b`
> записать КОПИЮ переменной `a`. То есть в `a` и `b` должны будут лежать РАЗНЫЕ объекты с одинаковыми значениями. И если один объект будет
> изменяться, то второй не нужно трогать. При этом это следует сделать, не просто вручную задав в переменную `b` то же значение, то есть:
> ```python
> a = [1, 2, 3]
> b = [1, 2, 3] 
> ```
> не прокатит! Я проверю!
> 
> Разберись, как делается реальная копия объекта, какие копирования бывают, и где можно применять их.
>> **Чарввалг**

### Задание 6

Твое любимое — разберись сам. Не подсказок, ничего... Ну да ладно, чего там нужно сделать?
1. Нужно поправить файл *src/task_6.py*.
2. Необходимо разобраться, что происходит в коде, и посмотреть результат текущей версии.
3. В функциях `example_1`, `example_2` и `example_3` необходимо поправить код так, чтобы в переменную `b` записывалась КОПИЯ переменной `a`. 
4. Проверкой будет служить вывод на экран того, что объекты разные, и их конечное наполнение (после изменения переменной `b`) тоже разное. То есть переменная `a` должна остаться в изначальном виде, а переменная `b` измениться.

## Chapter VI

### Ключевое слово del

> Ну и последнее, про что я хотел упомянуть — это про инструкцию `del` в Python. Посмотри, как она применяется и для чего нужна.
> Если вкратце, то `del` удаляет ссылку на объект.
> 
> А вот когда удаляется сам объект?
> 
> Тут-то и становится интересно. Как ты уже понял, на объект могут ссылаться много раз. Так вот, каждый объект внутри себя имеет счетчик ссылок,
> в котором записано, сколько ссылок на этот объект в данный момент существует. Если этот счетчик опускается до нуля (то есть все ссылки удалены),
> то в дело вступает **сборщик мусора** (**garbage collector**), который запускается вместе с интерпретатором и периодически отслеживает, 
> есть ли в памяти объекты, у которых счетчик ссылок равен нулю. Если такие находятся, то он удаляет их из памяти.
> 
> Я подготовил тебе пример в файле *materials/example_with_del.py*, в котором написан некий код. Посмотри, что в нем, и подумай, почему в итоге
> на экран выводится то, что выводится.
> 
> На этом все! Мне пора бежать, меня ждет куча других студентов, которым нужно пояснить за Питон. Передавай привет вашему главврачу!
>> **Чарввалг**

Размахивая полами медицинского халата, чарввалг выходит из кабинета.

## Chapter VII

### Задание 7

В кабинет снова заходит главврач, но уже в привычном виде.

> Что? Мой друг уже ушел?! Как же мы с ним разминулись. Не успел поболтать с ним по душам. А ты ведь знаешь, как приятно
> поговорить с умными людьми?
> 
> Надеюсь, он тебе помог глубже погрузиться в Питон. Если у тебя остались после него какие-то наработки, то не забудь загрузить их в GitLab.
>> **Главврач**

Сказать, что ты не понял, что вообще здесь произошло, — значит, ничего не сказать. Но факт остается фактом: пуш в GitLab никто не отменял.
Тебе остается запушить все наработки в GitLab в ветку `develop`, включая все файлы *.py* из папки *src/*.

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
