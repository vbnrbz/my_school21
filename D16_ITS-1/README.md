# Области видимости и декораторы

## Аннотация

Данный проект позволит тебе подробнее изучить, что такое декораторы, как их писать и как ими пользоваться. 

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Задание 1](#задание-1)
3. [Chapter III](#chapter-iii) \
    3.1. [Области видимости](#области-видимости) \
    3.2. [Присваивание функций](#присваивание-функций) \
    3.3. [Задание 2](#задание-2)
4. [Chapter IV](#chapter-iv) \
    4.1. [Декораторы](#декораторы) \
    4.2. [Задание 3](#задание-3) \
    4.3. [Еще немного о декораторах](#еще-немного-о-декораторах) \
    4.4. [Задание 4](#задание-4) \
    4.5. [Задание 5](#задание-5)
5. [Chapter V](#chapter-v) \
    5.1. [Бонусное задание 1](#бонусное-задание-1) \
    5.2. [Бонусное задание 2](#бонусное-задание-2)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер: 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!


### Введение

Ты слышишь, как открывается дверь, и уже готов увидеть главврача, входящего в кабинет.

> Доброе утро!
>> **Стажер**

Немного странно осознавать, что несмотря на небольшие причуды, ты уже успел проникнуть уважением к здешнему главврачу и с энтузиазмом приветствуешь его.

> Привет! Я смотрю, что ты уже ждешь меня? Ха-ха-ха, похвально-похвально! Ну что ж, постараюсь тебя не разочаровать!
> 
> Как ты уже понял, мы пошли с тобой изучать более продвинутые темы. Так не будем останавливаться! Ты уже немного узнал о функциональном
> программировании, пора изучить одну интересную тему — декораторы.
> 
> Предлагаю изучать эту тему на двух задачах:
> 1. Авторизация пользователя по логину и паролю.
> 2. Логирование.
>> **Главврач**

## Chapter II

### Задание 1

> Начнем с авторизации. Давай пока просто вспомним функциональное программирование. Декораторы на самом деле сильно завязаны
> на этом стиле программирования. В файле *src/task_1.py* я подготовил тебе две функции:
> 1. Функция `stub_write_recipe` имитирует формирование рецепта для пациента.
> 2. Функция `stub_add_to_schedule` имитирует запись пациента к врачу.
> 
> В файле *materials/users.json* содержатся логины и пароли сотрудников больницы с их ролью — врач
> или медсестра.
> 
> Для начала тебе необходимо:
> 1. Написать функцию `check_login_password`, которая должна принимать два аргумента:
>   - функцию, которую нужно будет выполнить;
>   - словарь с логинами и паролями, считанный с файла *materials/users.json*.
> 2. Функция `check_login_password` должна:
>   - запрашивать логин и пароль пользователя с клавиатуры (в разных инпутах):
>       - `Enter login: `;
>       - `Enter password: `;
>   - проверять, что они совпадают с логином и соответствующим ему паролем из переданного словаря;
>   - если совпадают, то необходимо выполнять переданную в качестве аргумента функцию и возвращать ее результат;
>   - если НЕ совпадают, то инициировать исключение `PermissionError` со следующим текстом: `Incorrect login or password!`.
> Как инициировать (или же возбуждать исключения), ты можешь вспомнить из проекта 3. Текст необходимо указывать внутри возбуждаемого исключения, а не в отдельном принте!
> 3. Считай файл и сделай вызовы функции `check_login_password` отдельно с двумя функциями: `stub_write_recipe` и `stub_add_to_schedule`
> в блоке `if __name__ == '__main__':`. Проверь себя таким образом, выводя результат на экран. Вводи существующие и несуществующие
> логин или пароль.
> 4. Не забудь про проставление аннотаций во всех местах, где их только можно проставить.
>> **Главврач**

Как же приятно, когда не нужно самому декомпозировать задачу, а за тебя это все уже сделали. Остается только запомнить, что
код надо реализовывать в уже созданном файле *src/task_1.py*.

## Chapter III

### Области видимости

> Итак, в данной реализации функция `check_login_password` принимает два аргумента — другую функцию и словарь с паролями.
> Каждый раз нам нужно будет передавать этот словарь в качестве параметра для этой функции при ее вызове. Однако существует
> еще один способ, как можно обращаться к переменным изнутри функции. Для этого необходимо понимать **области видимости переменных**.
> То есть откуда в коде видны (то есть их можно использовать) те или иные переменные.
> 
> Существует три области видимости:
> 1. Глобальная.
> 2. Локальная.
> 3. Нелокальная.
> 
> С глобальной все просто. Все переменные, которые записаны внутри файла с кодом, но не внутри функций или классов, являются **глобальными**.
> Глобальные переменные видны из любой части кода, из любой функции или класса. У программистов Python есть договоренность:
> объявлять такие переменные в верхнем регистре. Это позволяет сразу в коде понять, что эта переменная глобальная. Пример:
> ```python
> EXAMPLE_VARIABLE = 10
> 
> def func():
>   print(EXAMPLE_VARIABLE * 2)
> 
> func()
> ```
> 
> Однако есть один нюанс. Глобальные переменные можно читать и использовать внутри функций или методов. Но если ты попробуешь
> объявить такую же переменную внутри функции, то это уже получится другая переменная, которая будет существовать отдельно внутри
> этой функции! Например, попробуй скопировать куда-нибудь этот код и выполнить:
> ```python
> EXAMPLE_VARIABLE = 10
> 
> def func():
>   EXAMPLE_VARIABLE = 20
>   print(f'Это переменная EXAMPLE_VARIABLE внутри функции - {EXAMPLE_VARIABLE}')
> 
> func()
> print(f'А это переменная EXAMPLE_VARIABLE, заданная снаружи - {EXAMPLE_VARIABLE}')
> ```
> 
> Если же изнутри функции хочется изменить глобальную переменную, то нужно сделать определенное действие, а именно:
> ```python
> EXAMPLE_VARIABLE = 10
> 
> def func():
>   global EXAMPLE_VARIABLE
>   EXAMPLE_VARIABLE = 20
>   print(f'Это переменная EXAMPLE_VARIABLE внутри функции - {EXAMPLE_VARIABLE}')
> 
> func()
> print(f'А это переменная EXAMPLE_VARIABLE, заданная снаружи - {EXAMPLE_VARIABLE}')
> ```
> а именно написать строчку `global EXAMPLE_VARIABLE`: она и говорит Питону, что можно править глобальную переменную отсюда.
> 
> Это были буквально вводные пару слов, с остальными областями видимости (**локальной** и **нелокальной**), а также подробнее с глобальной разберись сам.
> Вот неплохая [статья](https://habr.com/ru/companies/otus/articles/487952/) на хабре на эту тему.
>> **Главврач**

### Присваивание функций

> Знаешь, чем мне не нравится код из первого задания? Какова наша цель? Чтобы перед запуском какой-либо функции была осуществлена
> авторизация, и левые люди не могли пользоваться программой. Но проблема в том, что с подходом из первого задания нам
> приходится вместо вызова отдельных функций писать вызов функции `check_login_password` и туда уже передавать нужную функцию. Хотелось
> бы, чтобы мы все-таки вызывали ту же самую функцию.
> 
> Какие есть идеи? Можно, конечно, в каждую из функций накопировать кусок кода с проверкой логина и пароля. Но представь, что
> функций не 2, а 50. Тебе придется копировать очень много раз. А потом в какой-то момент логика поменяется, и тебе нужно будет снова
> править в 50 местах этот код. Нет, это неправильный подход, такие куски должны быть определены в одном месте, чтобы их можно
> было легко менять в дальнейшем.
> 
> И вот тут нам помогут твои новые знания о функциональном программировании. Что там можно в Питоне делать с функциями, помнишь?
> В первом задании ты уже передаешь функцию в качестве аргумента. Но еще ее можно возвращать, а также присваивать другой переменной!
> 
> Используя эти особенности, можно переопределить любую функцию следующим образом:
> ```python
> def external_func(func):
>   print('Приветики-пистолетики')
>   return func
>
> def some_func(a, b):
>   return a + b
> 
> some_func = external_func(some_func)
> print(some_func(10, 3))
> ```
> 
> Скопируй этот пример в какой-нибудь временный файл и выполни. Ты увидишь, что, помимо выполнения действий внутри функции, 
> выполнился еще и принт. То есть по факту мы добавили новый функционал к функции `some_func`!
> 
> Разберись, что происходит в данном примере. Обрати внимание на то, что сам объект функции `some_func` и вызов этой
> функции `some_func()` — это две разные вещи! Объект функции — это специальная структура в памяти, хранящая внутри себя код этой функции, а вызов функции — это
> уже исполнение этого кода. Ты можешь написать `print(some_func)` и `print(type(some_func))` и посмотреть, что будет.
>> **Главврач**

### Задание 2

> Если ты разобрался, в чем тут фишка, то может показаться, что это круто. Мы в одной функции можем дописать код, который
> будет дополнять сразу куча других функций. Однако все не так радужно. Я подготовил тебе *файл src/task_2.py*.
> В нем я уже сделал переопределение двух функций `stub_write_recipe` и `stub_add_to_schedule` с помощью функции 
> `check_login_password`, а также написал логику вызова этих функций и еще сверху пару принтов. Тебе остается:
> 1. Определить переменную с глобальным словарем `DICT_USERS` с логинами и паролями.
> 2. Написать функцию `check_login_password`, которая принимает один аргумент — другую функцию. Внутри эта функция должна:
>     - запрашивать логин и пароль с клавиатуры и проверять их в глобальной переменной `DICT_USERS`;
>     - если проверка провалена, то вызывать то же исключение, что и в задании 1;
>     - если такие логин и пароль присутствуют в словаре, то необходимо выводить на экран фразу `Signal from function`, а затем
> возвращать переданную в качестве аргумента ФУНКЦИЮ (заметь, что ее **НЕ НАДО** вызывать и возвращать результат, нужно вернуть
> саму функцию как объект). 
> 3. После этого необходимо выполнить код, посмотреть порядок вывода на экран надписей и понять, в какой момент исполнения кода выполняется
> тот или иной принт.
>> **Главврач**

## Chapter IV

### Декораторы

> Надеюсь, ты заметил, что `Signal from function` печатается на экран на следующих моментах:
> ```python
> stub_write_recipe = check_login_password(stub_write_recipe)
> stub_add_to_schedule = check_login_password(stub_add_to_schedule)
> ```
> а не при вызове функций (`stub_write_recipe()` и `stub_add_to_schedule()`).
> 
> Это тоже не то, что мы хотим. Мы хотим, чтобы блок кода, связанный с авторизацией, выполнялся именно во время вызова функций
> `stub_write_recipe` и `stub_add_to_schedule`, а не во время их переопределений. Чтобы этот кусок кода выполнялся при вызове,
> необходимо обернуть всю основную логику функции `check_login_password` во вложенную функцию, которую и следует уже возвращать. Давай посмотрим на примере:
> ```python
> def external_func(func):
>   def wrapper(a, b):
>       print('Приветики-пистолетики')
>       return func(a, b)
>   return wrapper
>
> def some_func(a, b):
>   return a + b
> 
> some_func = external_func(some_func)
> print('Промежуточный сигнал')
> print(some_func(10, 3))
> ```
> Выполни этот код и посмотри порядок вывода принтов. В данном случае `Приветики-пистолетики` будут выводиться на экран уже
> во время выполнения функции (`print(some_func(10, 3))`), а не во время переопределения (`some_func = external_func(some_func)`).
> Заметь, кстати, что из функции `wrapper` мы обращаемся к аргументу `func`, который не передается в качестве аргумента для `wrapper` напрямую,
> а находится на уровень выше — привет области видимости. Также функция `wrapper` уже возвращает РЕЗУЛЬТАТ, а не функцию как объект.
> 
> Попробуй разобраться по шагам, что тут вообще происходит. Если супер упрощенно, то вложенная функция нужна, чтобы возвращать
> именно ее как объект. Это позволяет вызывать блок кода вложенной функции именно во время выполнения переопределенной функции.
> Я уверен, что это ломает тебе сейчас мозг. Это нормально, такое надо осознать, а также найти и прочитать более существенные
> разъяснения.
> 
> Кстати, чуть не забыл: вот эта функция `external_func` и есть **декоратор**, то есть специальная функция,
> которая позволяет добавить новую функциональность к другой функции, не изменяя ее исходный код.
> 
> Последнее, что скажу. В разных языках программирования есть такое понятие, как **синтаксический сахар**. Это когда
> язык позволяет записать какой-то смысловой код в более сокращенном виде. Так вот, для декораторов в Питоне есть свой
> синтаксический сахар для переопределения функции — `some_func = external_func(some_func)`. А именно:
> ```python
> def external_func(func):
>   def wrapper(a, b):
>       print('Приветики-пистолетики')
>       return func(a, b)
>   return wrapper
>
> @external_func
> def some_func(a, b):
>   return a + b
>
> print('Промежуточный сигнал')
> print(some_func(10, 3))
> ```
> 
> А вот и он — `@external_func`. Чтобы переопределить функцию с помощью декоратора, нужно над функцией написать знак собаки `@`
> и название декоратора.
>> **Главврач**

### Задание 3

> Ну что, предлагаю в подготовленном мной файле *src/task_3.py*:
> 1. Написать функцию `check_login_password` как декоратор. Всю основную логику декоратора необходимо реализовать в самом вложенном методе.
> 2. С помощью синтаксического сахара (в дальнейшем это будет подразумеваться по умолчанию для всех декораторов) обернуть
> функции `stub_write_recipe` и `stub_add_to_schedule` в декоратор `check_login_password`.
> 3. Предлагаю завести две глобальные переменные `DICT_USERS` и `IS_AUTHORIZED`. Для чего нужна первая, ты уже догадываешься.
> А вот вторую переменную я предлагаю использовать в следующем контексте. Раньше мы вводили логин и пароль при вызове КАЖДОЙ
> функции. На самом деле, это странно: во время запуска программы за компьютером будет сидеть один человек. Зачем его по сто раз
> спрашивать логин и пароль. Ты же при использовании, например, почты не вводишь логин и пароль при каждом чихе, а делаешь это всего один раз
> в самом начале. Поэтому предлагаю внутри декоратора (здесь всегда подразумевается вложенная функция декоратора):
>   - Запрашивать логин и пароль только при первом использовании этого декоратора, то есть при вызове первой функции, которая
> обернута в этот декоратор. Здесь же проверять логин и пароль в словаре `DICT_USERS` и возбуждать исключение при неверных логине
> или пароле.
>   - Если же это второй или далее вызов любой функции, обернутой в декоратор, то просто возвращать значение функции.
> 
>   Вот для этого я и советую использовать глобальную БУЛЕВУЮ переменную `IS_AUTHORIZED`, значение которой можно менять после
> первого ввода логина и пароля (не забудь про особенности изменения глобальной переменной изнутри функции — см. области видимости).
> На этом мои подсказки, как использовать эту переменную, заканчиваются.
> 4. Не забудь про аннотации!
>> **Главврач**

### Еще немного о декораторах

> И еще две вещи о декораторах.
> 
> Первая — это то, что на функцию можно навешивать сколько угодно декораторов:
> ```python
> def decorator_1(func):
>   def wrapper(a, b):
>       print('Декоратор 1')
>       return func(a, b)
>   return wrapper
> 
> 
> def decorator_2(func):
>   def wrapper(a, b):
>       print('Декоратор 2')
>       return func(a, b)
>   return wrapper
>
> @decorator_2
> @decorator_1
> def some_func(a, b):
>   return a + b
>
> print(some_func(10, 3))
> ```
> В каком порядке они будут выполняться — проверь сам.
> 
> И вторая вещь: можно создавать декораторы, которые принимают аргументы на вход. Реализация их не такая очевидная, 
> как может прийти в голову. Но это уже часть твоего задания — разберись, как такие декораторы (принимающие аргументы) создаются.
>> **Главврач**

### Задание 4

> А теперь давай наконец расширим наш функционал с авторизацией по максимуму. Я хочу, чтобы ты в подготовленном мной файле *src/task_4.py*:
> 1. Написал два декоратора:
>   - `check_login_password`, который не принимает аргументов. Декоратор должен делать все то же самое, что и в задании 3,
> и, помимо этого, при верной авторизации (логин и пароль верные), необходимо записывать в **ГЛОБАЛЬНУЮ** переменную `USER_ROLE`
> роль пользователя из словаря `DICT_USERS` — `doctor` или `nurse`. Опять же, как и с переменной `IS_AUTHORIZED`, делать это нужно один
> раз при первом использовании этого декоратора;
>   - `has_permission`, который принимает один аргумент `permission`, являющийся списком. Аргумент `permission` содержит список
> ролей, которым разрешено выполнение функции, оборачиваемой этим декоратором. Пример значения аргумента: `['doctor', 'nurse']`. Это означает, что функция,
> обернутая декоратором с таким аргументом, будет доступна для роли врача и медсестры. Внутри декоратор должен проверять, входит ли
> роль из глобальной переменной `USER_ROLE` в переданный список `permission`. Если входит, то необходимо выполнять обернутую декоратором функцию.
> Если не входит, то генерировать исключение  `PermissionError(f'The <подставить роль из USER_ROLE> does not have the right to perform the function <подставить имя функции>!')`.
> Пример сообщения исключения в терминале: `The nurse does not have the right to perform the function stub_write_recipe!`
> 2. Навесил на функции `stub_write_recipe` и `stub_add_to_schedule` декоратор `check_login_password` и декоратор `has_permission`.
> 3. Пусть функция `stub_write_recipe` выполняется только для роли доктор, а функция `stub_add_to_schedule` для ролей доктор
> и медсестра.
> 4. Очередность выполнения декораторов следующая: сначала проверка логина и пароля, потом проверка роли.
> 5. Не забудь про аннотации!
>> **Главврач**

### Задание 5

> Ты проделал хорошую работу сегодня. И я даю тебе два варианта: либо запушить свои задачи в GitLab и немного передохнуть, либо 
> же выполнить еще две задачи, чтобы закрепить тему с декораторами. Выбор за тобой.
>> **Главврач**

Хм, надо подумать, но в любом случае не помешает запушить текущие 4 задачи в GitLab в ветку `develop`.

## Chapter V

### Бонусное задание 1

> О, так ты решил остаться и закрепить свои знания. Очень похвально! Тогда не будем тянуть и сразу к делу.
> 
> В файле *src/task_bonus_1.py* я подготовил тебе также две функции: `stub_write_recipe`, принимающая два аргумента,
> один из которых имеет значение по умолчанию, и `stub_add_to_schedule`, имеющая два позиционных аргумента.
> 
> Я хочу, чтобы ты написал декоратор `log_execution_time`, который **логирует** в файл *src/execution_log_1.log* запись о выполнении
> функции (которая обернута этим декоратором) и с какими аргументами она была выполнена, ну и, естественно, выполняет саму функцию. 
> В файл необходимо дозаписывать данные, а не создавать каждый раз заново файл
> при любом запуске. Пример строчек с **логами** для двух запусков (которые присутствуют в файле с кодом *src/task_bonus_1.py*)
> можно посмотреть в файле *materials/execution_log_1.log*. Я надеюсь, понятно, что в `args=()` должны записываться те аргументы,
> которые были переданы позиционно, а в `kwargs={}` те аргументы, которые были переданы в формате `func(a=10)`.
> Кстати, реализуй в декораторе возможность, чтобы я мог передавать в функции `stub_write_recipe` и `stub_add_to_schedule`
> аргументы в абсолютно любом виде — в виде позиционных или именных.
> 
> Ну и не забудь, что нужно подставлять имя той функции, которая сейчас выполняется. Реализуй логирование вручную, не используя никаких библиотек.
> 
> И не забудь обернуть функции `stub_write_recipe` и `stub_add_to_schedule` в декоратор `log_execution_time`! Кстати, декоратор
> здесь не должен принимать никаких аргументов.
>> **Главврач**

> Извините, пожалуйста, а что такое логирование и логи? 
>> **Стажер**

> Совсем забыл, что ты можешь этого не знать! Все просто: логирование — это процесс записи каких-то событий, выполнения функций, 
> фиксирования каких-то сообщений из программы. Строчки-записи называются логами. Логи можно записывать в специальные программы,
> выводить на экран (`print()` тоже своего рода можно назвать логом) или же записывать в файл. Логирование повсеместно
> встречается во всех больших программных обеспечениях или небольших программах. Иначе, если что-то пойдет не так, ты не отследишь, что
> произошло. Ну или же просто надо собрать статистику, например, сколько раз пользователь нажал на рекламу на сайте. Все эти события
> логируются, и к ним в дальнейшем можно обратиться. 
> 
> А теперь вперед! И не забудь про аннотации!
>> **Главврач**

Ну что ж, надо реализовать код в файле *src/task_bonus_1.py* и после запушить его в GitLab в ветку `develop`!

### Бонусное задание 2

> Если ты еще не собираешься домой, то давай на сегодня последнюю задачку. Это правда последняя!
> 
> Возможно, ты уже догадываешься, что в Python под очень многие частые задачи существуют готовые модули. Так и с логированием.
> Используй в этот раз библиотеку `logging`, задай через `logging.basicConfig` основные параметры логов, включая файл, 
> куда они будут записываться: *src/execution_log_2.log*, формат даты и т. д. Уровень логов поставь на `INFO`.
> Да и вообще разберись, как работает библиотека `logging`. Твоя задача — используя библиотеку `logging`, поправить декоратор
> `log_execution_time`, переписав всю часть с логами на эту библиотеку.
> 
> При этом расширь функционал декоратора таким образом, чтобы если функция во время выполнения падала с ошибкой `TypeError`
> (эта ошибка обычно падает, когда что-то не так с передачей аргументов в функцию), то в файл с логами записывалось бы ПОЛНОЕ
> сообщение об ошибке, а декоратор при этом возвращал `None`.
> 
> Пример строчек с логами для четырех запусков (которые присутствуют в файле с кодом *src/task_bonus_2.py*)
> можно посмотреть в *materials/execution_log_2.log*.
> 
> И не забудь про аннотации!
> 
> Как сделаешь — можешь быть свободен до завтра. И так держать, осталось совсем чуть-чуть до конца твоей стажировки, держись!
>> **Главврач**

Что-то ты сегодня засиделся, надо уже реализовать этот код в файле *src/task_bonus_2.py*, запушить его в GitLab в ветку `develop` и наконец
пойти домой.

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
