# Коллекционные типы данных и циклы

## Аннотация

Данный проект позволит тебе изучить такие коллекционные типы данных, как кортежи, списки, словари и множества, работу с ними, а также циклы while и for.

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Рекомендации к проекту](#рекомендации-к-проекту) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Цикл while](#цикл-while) \
    2.2. [Задание 1](#задание-1)
3. [Chapter III](#chapter-iii) \
    3.1. [Операторы break и continue](#операторы-break-и-continue) \
    3.2. [Задание 2](#задание-2)
4. [Chapter IV](#chapter-iv) \
    4.1. [Множества](#множества) \
    4.2. [Задание 3](#задание-3)
5. [Chapter V](#chapter-v) \
    5.1. [Списки](#списки) \
    5.2. [Задание 4](#задание-4)
6. [Chapter VI](#chapter-vi) \
    6.1. [Словари](#словари) \
    6.2. [Задание 5](#задание-5)
7. [Chapter VII](#chapter-vii) \
    7.1. [Цикл for](#цикл-for) \
    7.2. [Задание 6](#задание-6)
8. [Chapter VIII](#chapter-viii) \
    8.1. [Задание 7](#задание-7)
9. [Chapter IX](#chapter-ix) \
    9.1. [Бонусное задание](#бонусное-задание)

## Chapter I

### Рекомендации к проекту

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. 

Как учиться в «Школе 21»:  
- На протяжении всего курса ты будешь самостоятельно добывать информацию. Пользуйся всеми доступными средствами поиска информации, к примеру, Google и GigaChat. Будь внимателен к источникам информации: проверяй, думай, анализируй, сравнивай. 
- Взаимообучение (P2P, Peer-to-Peer) — это процесс, при котором учащиеся обмениваются знаниями и опытом, выступая одновременно в роли учителей и учеников. Этот подход позволяет учиться не только у преподавателя, но и друг у друга, что способствует более глубокому пониманию материала.
- Не стесняйся просить помощи: вокруг тебя такие же пиры, которые тоже проходят этот путь впервые. Не бойся откликаться на просьбы о помощи. Твой опыт ценен и полезен, смело делись им с другими участниками. 
- Не списывай, а если пользуешься помощью — всегда разбирайся до конца, почему, как и зачем. Иначе твое обучение не будет иметь никакого смысла. 
- Если ты на чем-то застрял, и кажется, что ты уже все перепробовал, но все равно непонятно, куда идти, — просто передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову, и возможно, в следующий раз тебе наконец придет нужное решение!
- Важен не только результат обучения, но и сам процесс. Нужно не просто решить задачу, а понять, КАК ее решить. 
- Следи за временем при выполнении проекта. В день ты должен преодолевать минимум одно испытание. 
- Помни, что каждое задание по завершении проекта проходит ряд проверок: р2р-проверка с помощью чек-листа, проверка набором автотестов, проверка на стиль кода, проверка статическим анализатором, проверка на корректную работу с памятью. 

Как работать с проектом: 
- Перед выполнением проект необходимо склонировать с GitLab в одноименный репозиторий.
- Все файлы с кодом необходимо создавать в папке src/ склонированного репозитория.
- После клонирования проекта необходимо создать ветку `develop` и вести разработку в ней. После этого пушить в GitLab также нужно ветку `develop`.
- В качестве интерпретатора Python для всех проектов необходимо использовать единый интерпретатор, который ты создал в 1 проекте — **hospital_interpreter**.
- В твоей директории не должно быть иных файлов, кроме тех, что обозначены в заданиях.
- **Жирным** шрифтом будут выделены слова, на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
- *Курсивом* будут выделены имена папок и файлов, названия проектов и т. д.
- В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводиться кодом.
- В такой блок <insert...> (отличается от верхнего скобками < >) нужно подставить что-то из твоего кода, возможно, какую-то переменную.
- Каждое задание необходимо выполнять в отдельном файле. Название должно содержать task_ и номер задания. Например, task_1.py, task_2.py и т. д. Если задание подразумевает создание дополнительных файлов, то их местоположение в папке src и названия будут прописаны в теле задания.
- Все пути к файлам в коде указывай просто в виде строки. Не используй для этого библиотеки по типу `pathlib`. Это необходимо для корректной работы автотестов!
- Выход из программы **НЕ ДОЛЖЕН** осуществляться с помощью метода `exit` или же `sys.exit()`. Это также необходимо для корректной работы автотестов!

Дисклеймер: 
- Наша команда не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь, и мы все поправим!
- Иногда повествование ведется в несколько шутливой форме, чтобы не было скучно. Однако, как ты и сам знаешь, юмор и шутки — субъективная вещь. Поэтому если каламбуры в данном тексте, по твоему мнению, попахивают батиным юмором, то, пожалуйста, просто прими это.

Удачи тебе на этом тернистом, но определенно полезном пути!

### Введение

Ты сидишь утром в поликлинике, попиваешь кофе и думаешь о ~~нем~~, в смысле о Python. 

Пока ты пытаешься сдержать зевок, дверь открывается, и в нее входят уже знакомая тебе Антонина Павловна (для которой ты делал программу позавчера) и неизвестная женщина.
Вы обмениваетесь приветствиями.

> Лиза, это я тебе про него рассказывала. Наше новое айти-светило. Я уверена, что он сможет помочь тебе.\
> Ах да, прости, забыла представить тебе Елизавету Викторовну — нашу старшую медсестру, отвечающую за регистратуру.
> Елизавете Викторовне нужна твоя помощь в формировании очередей к врачам. Лиз, оставляю вас двоих, введи стажера в курс дела.
>> **Антонина Павловна (врач-терапевт)**

Антонина Павловна удаляется из кабинета.

> Приятно познакомиться, стажер! Да, Тоня все правильно сказала, я отвечаю за регистратуру. То есть мы выдаем пациентам карточки.
> Не делай такие глаза... Да, у нас все еще бумажные карточки пациентов. Но мы пытаемся цифровизоваться! Не зря же я к тебе пришла.
> 
> У меня появилась идея. Я слышала, что по стране в поликлиниках уже давно внедряется электронная очередь. У нас пока все по-старому: сколько людей пришло, столько и пришло. Очередь живая.
> Соответственно, абсолютно нет понимания ни у пациентов, ни у врачей о хотя бы примерном состоянии текущей очереди. Вот хотелось бы придумать что-нибудь такое эдакое, более современное.
> 
> Как считаешь, сможешь помочь?
>> **Елизавета Викторовна (старшая медсестра)**

> О чем речь? Конечно, я вам помогу!
>> **Стажер**

## Chapter II

### Цикл while

> Тоня, в смысле Антонина Павловна, говорила, что тебе лучше не ставить пока большую финальную задачу. Да и, честно говоря, я сама пока ее себе слабо представляю.
> Я так понимаю, что ты пока только учишься на эти клавиши жать в правильном порядке. Тогда точно давай реализовывать идеи постепенно.
> 
> Хм, с чего бы начать. Давай представим, что на каждого пациента врач уделяет сколько-то минут. То есть по такой логике за весь рабочий день у него не может быть больше пациентов, чем
> рабочее время в минутах, разделенное на количество минут на человека. Допустим, что мы пока это и сами в уме посчитаем.
> 
> Давай в программе будет задаваться какой-то предел, пока для простоты возьмем 4. В нашей очереди не должно быть больше этого предела.
> Так вот, я хочу для начала уметь делать два действия:
> 1. Добавлять пациента в очередь, пока не достигнут лимит.
> 2. В любой момент посмотреть текущую очередь.
> 
> Звучит как отличное начало. И еще одна ремарка. Во всех сегодняшних заданиях допускаем, что пользователь не ошибается при вводе.
> 
> Дерзай, я скоро вернусь.
>
>> **Елизавета Викторовна (старшая медсестра)**

Итак, получается, что нужно повторять одни и те же действия до тех пор, пока очередь не наполнится.
Где-то я видел, что для таких вещей существуют **циклы**. Кажется, у админа даже есть папка с таким именем.
Ты открываешь папку и видишь там два файла: *while.txt* и *for.txt*. Эники-бэники, пусть будет *while.txt*!

> В этой инструкции ты узнаешь немного о **цикле while**. Цикл while состоит из двух основных элементов: условия и **тела цикла**.
> Пока условие **истинно** (то есть равно True), будет выполняться тело цикла. Тело — это код внутри цикла.
> То есть когда код в теле заканчивается, идет новая проверка условия, если оно True, то тело заново выполняется.
> 
> Часто в условии `while` идет сравнение какого-то счетчика с предельным значением. А внутри тела цикла этот счетчик может уже меняться
> в зависимости от условий. Либо прибавляться, либо не изменяться, либо вообще уменьшаться! Не забудь, главное, до цикла объявить этот счетчик и сделать его равным нулю.
> 
> Ах да, условие ведет себя точно так же, как в условных конструкциях `if-else`. Если еще не в курсе, что это, то сначала прочитай о них!
> 
> У цикла `while` наподобие блока `try-except` есть блок `else`. Он выполняется всегда, когда цикл завершен по условию. А тут всплывает интрига:
> неужели можно его завершить раньше?

Интрига интригой, а время тикает, нужно приступать к заданию.

### Задание 1

Получается, что можно внутри этого **цикла while** организовать всю работу. Итак, значит, в итоге тебе нужно:
1. Задать лимит очереди — 4 человека.
2. Дать возможность до достижения лимита делать два действия:
    - добавлять пациента в очередь;
    - смотреть текущую очередь.
3. Очередь нужно организовать через строку. Между собой людей нужно разделять запятой с пробелом. 
Например: `Ivanov A.S., Petrov K.V., Sidorova G.U.`. Очередь пусть будет заканчиваться последним введенным в очередь пациентом, как в примере. Без добавления лишних знаков препинания.
4. Пусть пользователю до достижения лимита на каждой **итерации цикла** предлагается две опции для ввода с клавиатуры, обрамленные черточками:
    ```
    ----
    Enter:
     - 1, if you want to add a patient to the waiting list;
     - 2, if you want to see the current queue.
    ----
    ```
   При этом пусть черточек будет штук 50, тогда лучше будет видно отделение инпутов от ввода.
Черточками должна быть обрамлена только информация по поводу опций (как выше в примере).
5. При выборе опции 1 пусть пользователь вводит ФИО пациента, которого нужно добавить:
    ```
    Enter the full name of patient: 
    ```
   После двоеточия пусть будет пробел, а то введенное ФИО будет слепляться.
ФИО можно вводить в любом удобном виде — полностью или с помощью инициалов, но через запятую — `Ivanov Ivan Ivanovich, Petrov P.P.`
6. Текст, который видит врач при вводе, должен быть выведен на экран только с помощью `input`, а не через `print`!
7. При выборе опции 2 пусть пользователь видит текущую очередь в следующем виде (не забудь пробел после запятой):
    ```
    Current queue - Ivanov Ivan Ivanovich, Petrov P.P.
    ```
   То есть ФИО выводить в очереди так, как она была введена.
8. Когда лимит достигнут, пусть пользователь видит сформировавшуюся очередь, как в пункте 7. А после **программа должна быть завершена**.
9. И еще: пусть все выводы НЕ РАЗДЕЛЯЮТСЯ между собой лишней пустой строчкой, а идут друг за другом на следующей строчке.

## Chapter III

### Операторы break и continue

Ты показываешь получившийся результат вошедшей Елизавете Викторовне.

> Выглядит неплохо. Я вижу, что ты аккуратно вводишь все фамилии с большой буквы. Я обычно долго и медленно печатаю. Можно я буду вводить все с маленькой буквы, 
> а программа мне все равно будет в таком красивом виде показывать? Ну чтобы и фамилия с большой буквы, и инициалы.
> 
> Хочу еще две новые возможности. Во-первых, добавь, пожалуйста, опцию, чтобы я в любой момент могла остановить программу. При этом все равно пусть показывается полученная очередь, даже если она неполная.
> Во-вторых, хочу, чтобы если я заполнила очередь до конца, то выводилась надпись: «The queue is full!». А уже потом показывалась сама очередь.
> В-третьих, если я нечаянно нажму на просмотре пустой очереди, то пусть так и пишет: «The queue is empty!».
>> **Елизавета Викторовна (старшая медсестра)**

> Да, без проблем, сейчас все сделаю.
>> **Стажер**

Ты открываешь снова инструкцию админа и продолжаешь чтение.

> Да, циклы можно завершить раньше!
> 
> В циклах while и for можно использовать два особых оператора — `break` и `continue`. 
> 
> `break` — очень полезный оператор. Он позволяет сразу выйти из цикла, не дожидаясь выполнения условия. Обычно `break` пишут внутри условных конструкций в теле цикла.
> 
> `continue` — на первый взгляд не самый полезный оператор. Он позволяет сразу перепрыгнуть на следующую итерацию цикла.
> Давай посмотрим на пример. Код ниже выводит на экран только нечетные цифры от 0 до 10 с использованием ключевого слова `continue`.
> ```python
> count = 0
> 
> while count < 10:
>   count += 1
>   if count % 2 == 0:
>       continue
>   print(count)
> ```
> Советую выполнить этот код самому.
> 
> Однако ты можешь догадаться, что этот код можно переписать и в другом виде:
> ```python
> count = 0
> 
> while count < 10:
>   count += 1
>   if count % 2 != 0:
>       print(count)
> ```
> Он будет делать то же самое (можешь сам проверить) без использования `continue`. И на одну строчку даже меньше стало.
> В чем же тогда польза `continue`? \
> Приведу пример, где `continue` действительно раскрывается.\
> В теле цикла идет какой-то расчет (много кода), далее результат этого расчета проверяется в условной конструкции в теле цикла.
> Если условие удовлетворительно, то расчет продолжается (снова много кода). Но если условие неудовлетворительно, то идет переход к следующей итерации цикла.
> Если таких промежуточных проверок будет много, то получится очень много вложений `if-else` друг в друге. Это будет сильно портить читабельность кода.
> 
> В простых же случаях, как в представленном выше, `continue` можно легко заменить и не использовать.

### Задание 2

`break` — это, кажется, то, что тебе нужно для прерывания заполнения очереди. Что же нужно будет сделать дальше?

Последующие изменения/правки добавляются к предыдущему коду (то есть учитываются все пункты от 1 до 8 из Задания 1).
1. После ввода ФИО пациента с клавиатуры нужно приводить его в следующий вид: первая буква фамилии, имени и отчества должны быть с большой буквы,
в случае инициалов — большие буквы. Пример: Ivanov Ivan Ivanovich, Ivanov I.I.
2. Добавить опцию 3 во ввод с клавиатуры:
    ```
    ...
     - 3, if you want to terminate the program and see the resulting queue.
    ...
    ```
3. При выборе опции 3 пусть цикл прерывается, и перед завершением программы показывается текущая очередь (см. пункт 7 Задания 1).
4. Если очередь была заполнена до лимита, то перед последним показом очереди пусть показывается фраза «The queue is full!», а потом уже сама очередь:
    ```
    The queue is full!
    Current queue - Ivanov A.S., Petrov K.V., Sidorova G.U., Kirov Alexandr Alexandrovich
    ```
5. В случае если очередь пустая, то каждый раз, когда ее нужно вывести на экран, надо выводить фразу:
   ```
   The queue is empty!
   ```

P.S. Если программа завершена раньше заполнения лимита, то фразу «The queue is full!» выводить не надо!

## Chapter IV

### Множества

> Выглядит хорошо, а можно я сяду за компьютер и потестирую? Ага, я так и думала. Смотри, если я введу два раза одинаковые ФИО, то
> он запишет их обоих в очередь. Я бы этого не хотела, я ведь могу отвлечься на что-то и, вернувшись, записать нечаянно повторно того же пациента.
> Это просто займет одно место в очереди. Пусть программа сама проверяет, нет ли этого человека уже в очереди, и если есть, то пусть не добавляет его.
> 
> Логично, что если есть возможность добавить пациента в очередь, то должна быть возможность и удалить. Вдруг пациент отменит запись.
> Добавь, пожалуйста, возможность удаления. При этом, если такого пациента нет в очереди (вдруг опечатаюсь, вводя его ФИО), то пусть предупреждает меня об этом.
>> **Елизавета Викторовна (старшая медсестра)**

Удаление, удаление... Тебе все больше кажется, что делать все это через строки как-то странно.
Нужно глянуть, есть ли еще какие-нибудь подходящие типы данных для подобного. 

Ты роешься в записях админа и видишь файл *Коллекционные типы данных.txt*. О, что-то новенькое, нужно глянуть.

> Коллекционные типы данных (или просто **коллекции**) — это типы данных, которые позволяют тебе хранить и управлять группами объектов.
> Важная особенность Питона — это то, что одна коллекция позволяет хранить в себе разные типы данных.
> То есть если коллекция — это коробка, то эта коробка может хранить не только ручки, к примеру, но и торты. 
> В случае Питона одна коллекция может хранить внутри себя не только числа, но и строки, а может и другую коллекцию.
> 
> Существует несколько типов коллекционных данных в Питоне. Давай начнем с **множества**. **Множество** (**set**) — это как мешок. Как в мешке нет порядка очередности, так
> и во множестве отсутствует этот порядок, то есть отсутствуют **индексы**, которые были в той же строке.
> 
> Также множества хранят в себе только уникальные элементы. Если ты добавишь элемент, который уже есть в множестве — ничего не произойдет.
> В Питоне множества любят использовать, когда надо оставить только уникальные элементы в коллекции. Ты просто переводишь нужную коллекцию в множество, дубли при этом автоматически удаляются.
> 
> У любой коллекции в Питоне можно посчитать длину, т. е. посчитать количество элементов, которые входят в нее.
> 
> Кстати, помимо разделения на **примитивные и коллекционные**, типы данных также можно разделить на **изменяемые и неизменяемые**.
> У меня в другой инструкции про это подробнее рассказано, но давай возьмем в пример множество. Множества — изменяемый тип данных.
> В множество можно добавить данные, удалить и так далее, то есть изменять эту коллекцию. 
> Помимо обычного множества, есть еще **замороженные множества** (**frozenset**). Отличие от обычного множества простое — его нельзя изменять.
> Один раз задал и все, ни добавлять, ни удалять ничего оттуда нельзя. Зачем оно нужно, спросишь ты? Оно нужно, когда ты в коде один раз хочешь зафиксировать какую-то коллекцию,
> которую не будешь трогать, а хочешь просто проверять — есть ли в ней нужное тебе или нет. 
> 
> Например, ты можешь создать frozenset с запрещенными в стране лекарствами. И перед тем как назначить лекарство пациенту, проверять — есть ли оно там или нет.
> Один раз задал его и не трогаешь.

### Задание 3

Ты решаешь заменить строки на множества и добавить новый функционал уже с учетом множеств. Нужно записать себе необходимые пункты и обязательно перечитать их **ВСЕ**, перед тем как приступать к решению.

1. Вместо строки нужно использовать **множество**. Надо не забыть поменять механизм добавления с учетом него.
2. Вместо счетчика в условии цикла использовать длину множества. То есть сравнивать с лимитом длину текущей очереди.
3. Добавить опцию для удаления во ввод с клавиатуры.
    ```
    ...
     - 1, if you want to add a patient to the waiting list;
     - 2, if you want to remove a patient from the queue;
     - 3, if you want to see the current queue;
     - 4, if you want to terminate the program and see the resulting queue.
    ...
    ```
4. В пункте выше удаление обозначено как опция 2. В случае выбора опции 2 необходимо просить ввести ФИО пациента, которого хочется удалить.
    ```
    Enter the name of the patient to be removed from the queue: 
    ```
    После двоеточия нужно не забыть пробел.
5. Если такого пациента нет в очереди, то нужно выдать предупреждение пользователю:
    ```
    This patient is not in the waiting list!
    ```
    Если же есть, то удалить из нее.
6. Остальной функционал нужно оставить таким же, как в предыдущем задании.
7. С учетом замены строки на множество вывод текущей очереди будет выглядеть следующим образом:
    ```
    Current queue - {'Ivanov A.S.', 'Petrov K.V.', 'Sidorova G.U.', 'Kirov Alexandr Alexandrovich'}
    ```
    Править его не нужно!

## Chapter V

### Списки

Ты только заканчиваешь предыдущее задание, как в кабинет резко врывается Елизавета Викторовна.

> Я вот тут подумала и поняла, добавлять и удалять же я могу только по ФИО. А если я хочу удалить не по ФИО, а по месту в очереди?
> Например, освободить последнее место в очереди. Или же надо отменить первую запись. Как быть?
> 
> А насчет добавления, я имею в виду, что приходит ко мне бабушка, например, и говорит: «Милая, а дай, ради бога, карточку, надо быстренько к врачу зайти, мне только спросить!»
> Вот что я с ней буду делать, не заставлять же ждать кучу времени. Надо в программе закинуть в начало очереди.
> 
> Будь добр, учти, пожалуйста, все это в своей программе.
>> **Елизавета Викторовна (старшая медсестра)**

Так, удаление по номеру в очереди, можно, наверное, использовать для этого индекс... Так в множествах же нет индексов! Там элементы не по порядку расположены.
Похоже множества для этой задачи не подходят. Какие там еще есть коллекции?

> Еще одной коллекцией в Питоне являются **списки**. **Списки** (**list**) — это уже упорядоченные коллекции, которые также могут хранить в себе любые объекты.
> Списки — это **изменяемый** тип данных, в них можно добавлять элементы, удалять и т. д. Так как списки являются упорядоченными (прямо как строки — это упорядоченные символы),
> то у них тоже имеется механизм индексов и срезов, как у строк. Работают они абсолютно идентично.
> 
> Есть еще такой тип данных, как **кортеж**. Если список — это сын маминой подруги, то кортеж — это ты. А если серьезно, то **кортеж** (**tuple**) — это **неизменяемый список**.
> Все аналогично set и frozenset. В кортеж нельзя ничего добавлять, удалять и вообще менять его. Он нужен для того же, что и frozenset, только он еще и упорядочен.
> То есть к его элементам можно обращаться по индексам и срезам.

### Задание 4

Кажется, список уже можно использовать для добавления или удаления элементов по порядковому номеру в нем. Для этого можно применить индексы.

Пора зафиксировать для себя перечень дел. В этих заданиях главное — не забывать перечитывать **ВСЕ** пункты перед выполнением.
1. Заменить **множество** на **список** и переписать весь функционал, связанный с добавлением и удалением из него. 
2. При выборе опции 1 (добавить пациента в очередь) необходимо спрашивать, куда пользователь хочет добавить пациента — в конец или другую часть очереди:
    ```
    ----
    Enter:
     - 1, if you want to add a patient to the back of the queue;
     - 2, if you want to add a patient to the beginning or middle of the queue.
    ----
    ```
    Черточек должно быть также 50.

    2.1. После выбора ЛЮБОЙ подопции необходимо запросить ФИО на добавление (при этом не забыть оставить обработку из прошлого задания):
    ```
    Enter the full name of patient: 
    ```
    2.2. Если такой пациент уже есть в очереди, то нужно выдавать фразу:
    ```
    This patient is already on the waiting list!
    ```
    2.3. Если пациента нет в очереди и была выбрана подопция 1, то нужно просто добавить его в конец очереди.\
    2.4. Если пациента нет в очереди и была выбрана подопция 2, то нужно спросить, в какое место в очереди надо вставить пациента. При этом все пациенты с этого места и дальше съедут вправо.
    ```
    Specify where in the queue you want to place the patient: 
    ```
    Надо не забыть, что порядковый номер и **индекс** все же не совсем одно и то же.
3. При выборе опции 2 (удалить пациента из очереди) необходимо спрашивать, как пользователь хочет удалить пациента — по ФИО или порядковому номеру:
    ```
    ----
    Enter:
     - 1, if you want to delete a patient by full name;
     - 2, if you want to remove a patient by his or her number in the queue.
    ----
    ```
    3.1. После выбора подопции 1 необходимо запросить ФИО на удаление (при этом обработку ФИО никто не отменял):
    ```
    Enter the full name of patient: 
    ```
    3.2. Если такого пациента нет в очереди, то надо выдавать надпись (при этом программа не должна падать):
    ```
    This patient is not in the waiting list!
    ```
    3.3. После выбора подопции 2 необходимо запросить порядковый номер в очереди, который надо почистить:
    ```
    Enter the queue number of the person: 
    ```
    3.4. Если такого порядкового номера нет в очереди, то нужно выдавать ту же фразу, как и в пункте 3.2., программа при этом должна продолжать работу.
4. Остальной функционал нужно оставить таким же, как в предыдущей версии кода (предыдущем задании).
5. С учетом замены множества на список вывод текущей очереди будет выглядеть следующим образом:
    ```
    Current queue - ['Ivanov A.S.', 'Petrov K.V.', 'Sidorova G.U.', 'Kirov Alexandr Alexandrovich']
    ```
    Править его не нужно!


## Chapter VI

### Словари

После завершения задания ты с чистой совестью заварил себе кофейку и переводишь дух. В этот момент почти незаметно, с еле заметным скрипом отворяется дверь в кабинет.
В кабинет как-то неуверенно заходит старшая медсестра. Странно, думаешь ты, это сильно отличается от прошлого ее громкого появления.

> Слушай, я тут подумала немного. Ты только не огорчайся сильно. Мне кажется, что удобнее всего ориентироваться по времени, а не по порядковому номеру.
> Ну, то бишь, чтобы не просто очередь была. А прямо расписание: 10:00 — Petrov I.S., 10:30 — Ivanov A.A. и т. д. И чтобы я добавляла сразу время и ФИО.
> А удаление... Давай пока начнем с удаления по времени, если получится, то реализуем и по ФИО. А всю эту суету с порядковыми номерами можем удалить...
>> **Елизавета Викторовна (старшая медсестра)**

> ...
>> **Стажер**

> Ты уж прости сердечно, что я тебя гоняю. Семь пятниц на неделе, ей-богу, то так хочу, то этак. У меня в этой вашей цифровизации опыта мало, вот приходится на ходу учиться постановке задач, как и тебе программированию.
>> **Елизавета Викторовна (старшая медсестра)**

Елизавета Викторовна уходит, а ты бросаешь грустный взгляд в окно, вздыхаешь и думаешь.

> В настоящем айти, наверное, такого нет. Им там сразу поди нормально задачи ставят, и переделывать ничего не приходится.
>> **Твои мысли**

> АХАХАХАХАХАХХАХАХАХАХА
>> **Голос свыше**

Что это было?! Ну да ладно, на чем ты остановился. Нужно связать время и ФИО. И порядок больше не нужен, если вся связь будет идти через время.
Список уже не актуален, нужно искать что-то еще. Кажется, заметка по коллекциям еще не закончилась.

> Последняя по порядку, но далеко не по значению, коллекция — это **словарь**. **Словарь** (**dict**) — это неупорядоченный, как и множество, тип данных, где данные хранятся
> в виде **ключ**: **значение**. Всё почти как и в реальном словаре: ты ищешь слово (т. е. ключ), а определение этого слова — это значение.
> По ключу ты легко можешь получить значение. Словарь — это очень удобный тип данных для хранения и понятного поиска значения.
> 
> **Важная ремарка**. В качестве ключей словаря могут служить только **неизменяемые** типы данных (вообще я слышал, что не только, но мне сказали, что это уже очень глубокая и сложная тема),
> а в качестве значений могут быть любые типы данных.

### Задание 5

Тут все очевидно — пора переходить на словари. Интересно, сколько уже типов данных ты сменил в этой программе?
Похоже, необходимо сделать следующее (при этом перед реализацией нужно будет прочитать **ВСЕ** пункты для общей картины):
1. Заменить **список** на **словарь** и переписать весь функционал, связанный с добавлением и удалением из него.
2. Необходимо переписать старый функционал, лежащий под опциями 2 и 3 в Задании 4 (то есть функционал при выборе опций 1 и 2).
3. Теперь, при выборе опции 1 (добавить пациента в очередь) необходимо спрашивать время и ФИО пациента, пусть пользователь вводит их через запятую и пробел.
Кажется, что где-то в файле про строки ты видел какой-то полезный метод **split** для строк. Он должен помочь разделить время и ФИО. При этом также необходимо не забыть оставить обработку для ФИО. Пример инпута:
    ```
    Enter the time and the full name of patient (comma and space - 08:00, Ivanov A.A.): 
    ```
    3.1. Если время уже есть в ключах словаря, то надо выдавать фразу:
    ```
    That time is already taken!
    ```
    3.2. Если ФИО пациента уже есть в значениях словаря, то надо выдавать фразу:
    ```
    This patient is already on the waiting list!
    ```
    3.3. В остальных случаях можно добавлять информацию в словарь, **ключ** — время, **значение** — ФИО.
4. При выборе опции 2 (удалить пациента из очереди) необходимо спрашивать время, которое нужно очистить:
    ```
    Enter the time of the patient to be removed from the queue (e.g. 08:00 or 10:15): 
    ```
    4.1. Если такого времени нет среди ключей, то нужно выдавать фразу:
    ```
    This time is free!
    ```
    4.2. В остальных случаях удалять время и ФИО из словаря.
5. Остальной функционал нужно оставить таким же, как в предыдущей версии кода (в предыдущем задании).
6. С учетом замены списка на словарь вывод текущей очереди будет выглядеть следующим образом:
    ```
    Current queue - {'08:00': 'Ivanov A.S.', '09:15': 'Petrov K.V.', '10:30': 'Sidorova G.U.', '12:50': 'Kirov Alexandr Alexandrovich'}
    ```
    Править его не нужно!

## Chapter VII

### Цикл for

Ты дописываешь последние строки кода, когда за спиной раздается голос:

> Выглядит мудрено. Как успехи?
>> **Елизавета Викторовна (старшая медсестра)**

Ты вздрагиваешь! Кажется, ты так заработался, что не заметил, как она вошла.

> Почти дописал.
>> **Стажер**

> Какой ты молодец! Не зря тебя мне нахваливали. Осталась финишная прямая.
>
> Смотри, раньше мы удаляли по ФИО, но, честно говоря,
> мне не хочется каждый раз вписывать полностью ФИО для удаления. Я ведь могу посмотреть очередь до этого и, если там нет, например, однофамильцев, то удалить просто по фамилии.
> А может и вообще ввести часть фамилии. Допустим, есть в очереди Ivanov I.S., я ввожу «Ivan», и программа удаляет все ФИО, где есть это сочетание. Даже не одно, а все, вдруг понадобиться.
> Как тебе?! Мне кажется, что очень гибко. Если же нужно, то введу полное ФИО.
> 
> Только не учитывай, пожалуйста, регистр. Пусть я могу ввести «ivan», а Ivanov I.S. все равно найдется и удалится.
>
> Давай реализуем это и закончим.
>> **Елизавета Викторовна (старшая медсестра)**

Ты ведь не можешь удалить из словаря ключ, зная значение, получится только наоборот. Как же это сделать? Как будто надо как-то пройтись по всем парам ключ-значение, проверить значения и, если есть совпадение, то уже удалять этот ключ из словаря вместе со значением. Кажется, это придется делать в каком-то цикле. Но как будто while не сильно предназначен для такой задачи.

Ты вспоминаешь, что в папке с инструкциями по циклам рядом с файлом *while.txt* лежал файл *for.txt*. Ты решаешь заглянуть в него.

> Цикл `for` — это рабочая лошадка языка Питон. Если нужно пройтись по элементам какой-то коллекции, то тебе нужен цикл `for`.
> Обязательно посмотри еще, что значит метод `range`, он часто применяется с `for`, но когда нужно пройтись просто по последовательности чисел, например, от 1 до 100.
>
> Вообще, цикл `for` позволяет проходиться не только по коллекциям...

На этом моменте ты останавливаешься. Нет, всё, этой информации тебе достаточно. Больше новой информации твоя голова сегодня не выдержит...

### Задание 6

Кажется, нужно воткнуть этот цикл `for` в опцию 2. А если подробнее, то:
1. При выборе опции 2 (удалить пациента из очереди) необходимо спрашивать, как пользователь хочет удалить пациента — по времени или ФИО:
    ```
    ----
    Enter:
     - 1, if you want to time-delay a patient;
     - 2, if you want to delete a patient by full name.
    ----
    ```
    1.1. После выбора подопции 1 необходимо запросить время на удаление:
    ```
    Enter the time of the patient to be removed from the queue (e.g. 08:00 or 10:15): 
    ```
    1.2. Если такого времени нет среди ключей, то нужно выдавать фразу:
    ```
    This time is free!
    ```
    1.3. После выбора подопции 2 необходимо запросить ФИО или часть ФИО на удаление (при этом регистр не должен иметь значение):
    ```
    Enter the full name (or part of the full name) of the patients you want to remove from the queue: 
    ```
    1.4. Далее нужно с помощью цикла **for** найти те ключи, в значения которых входит введенная часть. При этом регистр нужно не учитывать (Ivanov и ivanov должны быть одним и тем же).\
    1.5. Если таких ключей найдено не было, то нужно выдавать фразу:  
    ```
    Those patients are not on the waiting list!
    ```
    1.6. Если такие ключи найдены, то их нужно удалить их вместе с их значениями из словаря.
2. Остальной функционал нужно оставить таким же, как в предыдущей версии кода (в предыдущем задании).

## Chapter VIII

### Задание 7

Как же ты задолбался за день, не передать словами...

> Ну что, доделал, бедолага?
>> **Елизавета Викторовна (старшая медсестра)**

> Да, все, что вы просили, реализовано.
>> **Стажер**

> Тоня была права на все сто, ты большой умничка! Она еще просила передать, чтобы ты не забыл кинуть свои наработки в GitLab в ветку `develop`.
> И огромное тебе спасибо! Оглянуться не успеем, как цифровизируемся и обгоним по технологиям поликлинику №33 из Зареченского района! Галя мне просто обзавидуется!
>> **Елизавета Викторовна (старшая медсестра)**

Кто такая Галя... А хотя, какое тебе дело?
Осталось только **запушить** свои наработки на **GitLab** в ветку `develop`.

> Если тесты не проходят, то можешь посмотреть пример работы программы в файле *materials/example_of_work.md*.
>> **Голос свыше**

## Chapter IX

Ты уже подходишь к двери кабинета, чтобы уйти домой, как в голову тебе приходит одна мысль:

> Хм, а может мне еще чуток задержаться и немного потренироваться Питону для себя?
>> **Твои мысли**

Ты понимаешь, что это уже не входит в твои обязанности по практике. Можно со спокойной совестью развернуться и пойти отдыхать.
Ты и так проделал сегодня отличную работу! Что же ты решаешь: остаться или пойти домой?

**На случай если ты решишь остаться, тебя ждет бонусное задание (оно не обязательно, но принесет тебе дополнительные знания и очки опыта в случае успешного выполнения).**

Ты решаешь остаться, садишься за компьютер и задумываешься. Какую бы задачу придумать, чтобы потренироваться?

Тебе приходит в голову следующая идея. В данный момент ты сконцентрирован на изучении 3 языков: латыни, английского и python.
Для тебя они сейчас находятся в одинаковом приоритете. И ты хочешь, чтобы программа рандомно сформировала тебе расписание — в какой день недели следующего месяца что тебе ботать.

Ты накидываешь себе на листочке вид, в котором ты бы хотел видеть это расписание, получается следующее:
```
|    | Mo      | Tu      | We      | Th      | Fr      | Sa      | Su     |
|----|---------|---------|---------|---------|---------|---------|--------|
|  1 | Rest    | Latin   | English | English | English | English | Python |
|  2 | English | Rest    | Latin   | English | English | Python  | Latin  |
|  3 | Rest    | English | Python  | English | Rest    | Python  | Latin  |
|  4 | Rest    | Latin   | Rest    | Latin   | English | Latin   | Python |
```

Как же это можно реализовать в Питоне... А что если представить это в таком виде:
```python
[
    ['1', 'English', 'Python', 'Rest', ...],
    ['2', 'English', 'Python', 'Rest', ...],
    ['3', 'Latin', 'Rest', 'Python', ...],
    ['4', 'Rest', 'Python', 'Latin', ...],
]
```

А как же представить это в таком красивом виде, какой ты себе набросал? Ты ищешь полезную информацию в файлах админа и находишь файл *pretty_print.txt*.

> Если тебе нужно вывести список или список списков в красивом виде, то можно использовать сторонние библиотеки.
> Например, библиотеку `tabulate`. Изучи, как она работает, там можно выводить данные в разных красивых форматах.
> 
> P.S. Мне больше всего нравится формат ***github***.

### Бонусное задание

Выглядит так, что у тебя фиксированная таблица, где кол-во строк равно всегда 4 (примерное кол-во недель в месяце), а столбцов всегда 7 (по дням недели).
Тогда тебе нужно:

1. Изучить, как работает библиотека `tabulate`.
2. Сформировать список, состоящий из четырех списков, описывающих одну неделю, каждый из которых включает номер недели и 7 **рандомных** выборов из списка: `['Latin', 'English', 'Python', 'Rest']`.
Вероятно, для этого можно использовать два вложенных цикла **for** и библиотеку **random**.
3. Используя библиотеку `tabulate`, вывести данный список списков с заголовками на экран.
4. Список с заголовками дней недель следующий: `['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su']`.
5. Назвать файл с кодом этого задания *task_bonus.py* и закинуть в папку *src/* этого репозитория в ветке `develop`.
6. Запушить этот файл вместе с остальными заданиями на GitLab в ветку `develop`.

---

💡 [Нажми сюда](http://opros.so/gRcUp), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
